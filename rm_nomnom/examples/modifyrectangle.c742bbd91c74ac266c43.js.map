{"version":3,"sources":["webpack:///./node_modules/openlayers/src/ol/interaction/ModifyEventType.js","webpack:///./node_modules/openlayers/src/ol/interaction/Modify.js","webpack:///./node_modules/openlayers/src/ol/source/OSM.js","webpack:///./examples/modifyrectangle.js","webpack:///./src/interaction/ModifyRectangle.js","webpack:///./node_modules/openlayers/src/ol/source/XYZ.js"],"names":["ModifyEventType","MODIFYSTART","MODIFYEND","Modify","options","features","Pointer","call","this","handleDownEvent","handleDragEvent","handleEvent","handleUpEvent","condition_","condition","defaultDeleteCondition_","mapBrowserEvent","Object","deleteCondition_","deleteCondition","insertVertexCondition_","insertVertexCondition","vertexFeature_","vertexSegments_","lastPixel_","ignoreNextSingleClick_","modified_","rBush_","RBush","pixelTolerance_","undefined","pixelTolerance","snappedToVertex_","changingFeature_","dragSegments_","overlay_","Vector","source","source_Vector","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileAnimating","updateWhileInteracting","SEGMENT_WRITERS_","Point","writePointGeometry_","LineString","writeLineStringGeometry_","LinearRing","Polygon","writePolygonGeometry_","MultiPoint","writeMultiPointGeometry_","MultiLineString","writeMultiLineStringGeometry_","MultiPolygon","writeMultiPolygonGeometry_","Circle","writeCircleGeometry_","GeometryCollection","writeGeometryCollectionGeometry_","source_","Collection","getFeatures","events","VectorEventType","ADDFEATURE","handleSourceAdd_","REMOVEFEATURE","handleSourceRemove_","Error","features_","forEach","addFeature_","bind","CollectionEventType","ADD","handleFeatureAdd_","REMOVE","handleFeatureRemove_","lastPointerEvent_","compareIndexes","a","b","index","evt","handlePointerAtPixel_","pixel","map","pixelCoordinate","getCoordinateFromPixel","length","vertexFeature","insertVertices","vertex","getGeometry","getCoordinates","vertexExtent","extent","segmentDataMatches","getInExtent","componentSegments","sort","i","ii","segmentDataMatch","segment","uid","ol","feature","depth","join","Array","geometry","getType","GeometryType","CIRCLE","MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX","closestVertex","closestOnSegmentData","coordinate","push","LINE_STRING","MULTI_LINE_STRING","willModifyFeatures_","j","insertVertex_","apply","dragSegment","segmentData","coordinates","getStride","POINT","MULTI_POINT","POLYGON","MULTI_POLYGON","MODIFY_SEGMENT_CIRCLE_CENTER_INDEX","setCenter","setRadius","getCenter","setGeometryCoordinates_","createOrUpdateVertexFeature_","centerSegmentData","featureSegments","circumferenceSegmentData","update","getExtent","dispatchEvent","Event","MapBrowserPointerEvent","handled","getView","getInteracting","type","MapBrowserEventType","POINTERMOVE","handlingDownUpSequence","handlePointerMove_","SINGLECLICK","removePoint","pointDistanceToSegmentDataSquared","pointCoordinates","circleGeometry","distanceToCenterSquared","distanceToCircumference","Math","sqrt","getRadius","getClosestPoint","prototype","getMap","isRendered","getActive","EventType","CHANGE","handleFeatureChange_","removeFeature_","removeFeatureSegmentData_","getLength","getSource","removeFeature","rBush","nodesToRemove","node","remove","setActive","active","setMap","event","insert","points","slice","lines","jj","rings","polygons","k","kk","geometries","getGeometriesArray","setCoordinates","Feature","addFeature","sortByDistance","box","getResolution","nodes","closestSegment","vertexPixel","getPixelFromCoordinate","dist","vertexSegments","pixel1","pixel2","squaredDist1","squaredDist2","min","splice","rTree","updateSegmentIndices_","newSegmentData","newSegmentData2","POINTERDRAG","removeVertex_","dragSegments","segmentsByFeature","component","left","newIndex","right","deleted","pop","segments","delta","forEachInExtent","array","Style","createDefaultEditing","resolution","mapBrowserPointerEvent","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_1__source_XYZ_js__","__webpack_require__","OSM","opt_options","attributions","ATTRIBUTION","crossOrigin","url","cacheSize","opaque","maxZoom","reprojectionErrorThreshold","tileLoadFunction","__WEBPACK_IMPORTED_MODULE_0__index_js__","exports","module","angular","_module3","default","name","MainController","_Map2","layers","_Tile2","_OSM2","view","_View2","center","zoom","rectangle","_Polygon2","_Collection2","_Feature2","isRectangle","styles","_Style2","fill","_Fill2","color","stroke","_Stroke2","width","image","_Circle2","radius","zIndex","concat","vectorSource","_Vector4","_Vector2","interaction","_ModifyRectangle2","addInteraction","controller","olBase","olEvents","_asserts2","assert","_Pointer2","handleDown_","handleDrag_","handleUp_","_Modify2","vectorPoints_","visible","feature_","cache_","params_","listen","inherits","setVisible","featureGeom","getUid","item","pointSource","corners","shift","pointFeatures","cornerPoint","cornerFeature","corner","_Point2","siblingX","siblingY","boxFeature","previousFeature","nextFeature","set","addFeatures","initializeParams_","get","assertInstanceof","origin","originPoint","originCoordinate","originPixel","siblingXPoint","siblingXCoordinate","siblingXPixel","vectorX","vectorXMagnitude","siblingYPoint","siblingYCoordinate","siblingYPixel","vectorY","vectorYMagnitude","isNaN","element","forEachFeatureAtPixel","destinationPixel","b2Pixel","calculateNewPixel_","b2Coordinate","c2Pixel","c2Coordinate","geom","destination","vector","aVector","abScalarProduct","deltaVector","__WEBPACK_IMPORTED_MODULE_2__tilegrid_js__","XYZ","projection","tileGrid","minZoom","tileSize","__WEBPACK_IMPORTED_MODULE_1__source_TileImage_js__","tilePixelRatio","tileUrlFunction","urls","transition"],"mappings":"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","file":"modifyrectangle.c742bbd91c74ac266c43.js","sourcesContent":["/**\n * @module ol/interaction/ModifyEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered upon feature modification start\n   * @event ol.interaction.Modify.Event#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ol.interaction.Modify.Event#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/interaction/ModifyEventType.js\n// module id = null\n// module chunks = ","/**\n * @module ol/interaction/Modify\n */\nimport {getUid, inherits} from '../index.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\nimport {equals} from '../array.js';\nimport {equals as coordinatesEqual, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment, closestOnSegment} from '../coordinate.js';\nimport {listen, unlisten} from '../events.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {always, primaryAction, altKeyOnly, singleClick} from '../events/condition.js';\nimport {boundingExtent, buffer, createOrUpdateFromCoordinate} from '../extent.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport ModifyEventType from '../interaction/ModifyEventType.js';\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\nimport Style from '../style/Style.js';\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n *\n * @constructor\n * @extends {ol.interaction.Pointer}\n * @param {olx.interaction.ModifyOptions} options Options.\n * @fires ol.interaction.Modify.Event\n * @api\n */\nconst Modify = function(options) {\n\n  PointerInteraction.call(this, {\n    handleDownEvent: handleDownEvent,\n    handleDragEvent: handleDragEvent,\n    handleEvent: handleEvent,\n    handleUpEvent: handleUpEvent\n  });\n\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.condition_ = options.condition ? options.condition : primaryAction;\n\n\n  /**\n   * @private\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.\n   * @return {boolean} Combined condition result.\n   */\n  this.defaultDeleteCondition_ = function(mapBrowserEvent) {\n    return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n  };\n\n  /**\n   * @type {ol.EventsConditionType}\n   * @private\n   */\n  this.deleteCondition_ = options.deleteCondition ?\n    options.deleteCondition : this.defaultDeleteCondition_;\n\n  /**\n   * @type {ol.EventsConditionType}\n   * @private\n   */\n  this.insertVertexCondition_ = options.insertVertexCondition ?\n    options.insertVertexCondition : always;\n\n  /**\n   * Editing vertex.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.vertexFeature_ = null;\n\n  /**\n   * Segments intersecting {@link this.vertexFeature_} by segment uid.\n   * @type {Object.<string, boolean>}\n   * @private\n   */\n  this.vertexSegments_ = null;\n\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n  this.lastPixel_ = [0, 0];\n\n  /**\n   * Tracks if the next `singleclick` event should be ignored to prevent\n   * accidental deletion right after vertex creation.\n   * @type {boolean}\n   * @private\n   */\n  this.ignoreNextSingleClick_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.modified_ = false;\n\n  /**\n   * Segment RTree for each layer\n   * @type {ol.structs.RBush.<ol.ModifySegmentDataType>}\n   * @private\n   */\n  this.rBush_ = new RBush();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n    options.pixelTolerance : 10;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.snappedToVertex_ = false;\n\n  /**\n   * Indicate whether the interaction is currently changing a feature's\n   * coordinates.\n   * @type {boolean}\n   * @private\n   */\n  this.changingFeature_ = false;\n\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.dragSegments_ = [];\n\n  /**\n   * Draw overlay where sketch features are drawn.\n   * @type {ol.layer.Vector}\n   * @private\n   */\n  this.overlay_ = new VectorLayer({\n    source: new VectorSource({\n      useSpatialIndex: false,\n      wrapX: !!options.wrapX\n    }),\n    style: options.style ? options.style :\n      Modify.getDefaultStyleFunction(),\n    updateWhileAnimating: true,\n    updateWhileInteracting: true\n  });\n\n  /**\n  * @const\n  * @private\n  * @type {Object.<string, function(ol.Feature, ol.geom.Geometry)>}\n  */\n  this.SEGMENT_WRITERS_ = {\n    'Point': this.writePointGeometry_,\n    'LineString': this.writeLineStringGeometry_,\n    'LinearRing': this.writeLineStringGeometry_,\n    'Polygon': this.writePolygonGeometry_,\n    'MultiPoint': this.writeMultiPointGeometry_,\n    'MultiLineString': this.writeMultiLineStringGeometry_,\n    'MultiPolygon': this.writeMultiPolygonGeometry_,\n    'Circle': this.writeCircleGeometry_,\n    'GeometryCollection': this.writeGeometryCollectionGeometry_\n  };\n\n\n  /**\n   * @type {ol.source.Vector}\n   * @private\n   */\n  this.source_ = null;\n\n  let features;\n  if (options.source) {\n    this.source_ = options.source;\n    features = new Collection(this.source_.getFeatures());\n    listen(this.source_, VectorEventType.ADDFEATURE,\n      this.handleSourceAdd_, this);\n    listen(this.source_, VectorEventType.REMOVEFEATURE,\n      this.handleSourceRemove_, this);\n  } else {\n    features = options.features;\n  }\n  if (!features) {\n    throw new Error('The modify interaction requires features or a source');\n  }\n\n  /**\n   * @type {ol.Collection.<ol.Feature>}\n   * @private\n   */\n  this.features_ = features;\n\n  this.features_.forEach(this.addFeature_.bind(this));\n  listen(this.features_, CollectionEventType.ADD,\n    this.handleFeatureAdd_, this);\n  listen(this.features_, CollectionEventType.REMOVE,\n    this.handleFeatureRemove_, this);\n\n  /**\n   * @type {ol.MapBrowserPointerEvent}\n   * @private\n   */\n  this.lastPointerEvent_ = null;\n\n};\n\ninherits(Modify, PointerInteraction);\n\n\n/**\n * @define {number} The segment index assigned to a circle's center when\n * breaking up a cicrle into ModifySegmentDataType segments.\n */\nModify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX = 0;\n\n/**\n * @define {number} The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n */\nModify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.addFeature_ = function(feature) {\n  const geometry = feature.getGeometry();\n  if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {\n    this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);\n  }\n  const map = this.getMap();\n  if (map && map.isRendered() && this.getActive()) {\n    this.handlePointerAtPixel_(this.lastPixel_, map);\n  }\n  listen(feature, EventType.CHANGE,\n    this.handleFeatureChange_, this);\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Map browser event\n * @private\n */\nModify.prototype.willModifyFeatures_ = function(evt) {\n  if (!this.modified_) {\n    this.modified_ = true;\n    this.dispatchEvent(new Modify.Event(\n      ModifyEventType.MODIFYSTART, this.features_, evt));\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.removeFeature_ = function(feature) {\n  this.removeFeatureSegmentData_(feature);\n  // Remove the vertex feature if the collection of canditate features\n  // is empty.\n  if (this.vertexFeature_ && this.features_.getLength() === 0) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n  unlisten(feature, EventType.CHANGE,\n    this.handleFeatureChange_, this);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.removeFeatureSegmentData_ = function(feature) {\n  const rBush = this.rBush_;\n  const /** @type {Array.<ol.ModifySegmentDataType>} */ nodesToRemove = [];\n  rBush.forEach(\n    /**\n     * @param {ol.ModifySegmentDataType} node RTree node.\n     */\n    function(node) {\n      if (feature === node.feature) {\n        nodesToRemove.push(node);\n      }\n    });\n  for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n    rBush.remove(nodesToRemove[i]);\n  }\n};\n\n\n/**\n * @inheritDoc\n */\nModify.prototype.setActive = function(active) {\n  if (this.vertexFeature_ && !active) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n  PointerInteraction.prototype.setActive.call(this, active);\n};\n\n\n/**\n * @inheritDoc\n */\nModify.prototype.setMap = function(map) {\n  this.overlay_.setMap(map);\n  PointerInteraction.prototype.setMap.call(this, map);\n};\n\n\n/**\n * @param {ol.source.Vector.Event} event Event.\n * @private\n */\nModify.prototype.handleSourceAdd_ = function(event) {\n  if (event.feature) {\n    this.features_.push(event.feature);\n  }\n};\n\n\n/**\n * @param {ol.source.Vector.Event} event Event.\n * @private\n */\nModify.prototype.handleSourceRemove_ = function(event) {\n  if (event.feature) {\n    this.features_.remove(event.feature);\n  }\n};\n\n\n/**\n * @param {ol.CollectionEvent} evt Event.\n * @private\n */\nModify.prototype.handleFeatureAdd_ = function(evt) {\n  this.addFeature_(/** @type {ol.Feature} */ (evt.element));\n};\n\n\n/**\n * @param {ol.events.Event} evt Event.\n * @private\n */\nModify.prototype.handleFeatureChange_ = function(evt) {\n  if (!this.changingFeature_) {\n    const feature = /** @type {ol.Feature} */ (evt.target);\n    this.removeFeature_(feature);\n    this.addFeature_(feature);\n  }\n};\n\n\n/**\n * @param {ol.CollectionEvent} evt Event.\n * @private\n */\nModify.prototype.handleFeatureRemove_ = function(evt) {\n  const feature = /** @type {ol.Feature} */ (evt.element);\n  this.removeFeature_(feature);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.Point} geometry Geometry.\n * @private\n */\nModify.prototype.writePointGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n  const segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    segment: [coordinates, coordinates]\n  });\n  this.rBush_.insert(geometry.getExtent(), segmentData);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiPoint} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\n  const points = geometry.getCoordinates();\n  let coordinates, i, ii, segmentData;\n  for (i = 0, ii = points.length; i < ii; ++i) {\n    coordinates = points[i];\n    segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      depth: [i],\n      index: i,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.LineString} geometry Geometry.\n * @private\n */\nModify.prototype.writeLineStringGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n  let i, ii, segment, segmentData;\n  for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    segment = coordinates.slice(i, i + 2);\n    segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      index: i,\n      segment: segment\n    });\n    this.rBush_.insert(boundingExtent(segment), segmentData);\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiLineString} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\n  const lines = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, segment, segmentData;\n  for (j = 0, jj = lines.length; j < jj; ++j) {\n    coordinates = lines[j];\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [j],\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.Polygon} geometry Geometry.\n * @private\n */\nModify.prototype.writePolygonGeometry_ = function(feature, geometry) {\n  const rings = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, segment, segmentData;\n  for (j = 0, jj = rings.length; j < jj; ++j) {\n    coordinates = rings[j];\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [j],\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiPolygon} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\n  const polygons = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;\n  for (k = 0, kk = polygons.length; k < kk; ++k) {\n    rings = polygons[k];\n    for (j = 0, jj = rings.length; j < jj; ++j) {\n      coordinates = rings[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          feature: feature,\n          geometry: geometry,\n          depth: [j, k],\n          index: i,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n};\n\n\n/**\n * We convert a circle into two segments.  The segment at index\n * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX} is the\n * circle's center (a point).  The segment at index\n * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX} is\n * the circumference, and is not a line segment.\n *\n * @param {ol.Feature} feature Feature.\n * @param {ol.geom.Circle} geometry Geometry.\n * @private\n */\nModify.prototype.writeCircleGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCenter();\n  const centerSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    index: Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX,\n    segment: [coordinates, coordinates]\n  });\n  const circumferenceSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    index: Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX,\n    segment: [coordinates, coordinates]\n  });\n  const featureSegments = [centerSegmentData, circumferenceSegmentData];\n  centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;\n  this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n  this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.GeometryCollection} geometry Geometry.\n * @private\n */\nModify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\n  const geometries = geometry.getGeometriesArray();\n  for (let i = 0; i < geometries.length; ++i) {\n    this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);\n  }\n};\n\n\n/**\n * @param {ol.Coordinate} coordinates Coordinates.\n * @return {ol.Feature} Vertex feature.\n * @private\n */\nModify.prototype.createOrUpdateVertexFeature_ = function(coordinates) {\n  let vertexFeature = this.vertexFeature_;\n  if (!vertexFeature) {\n    vertexFeature = new Feature(new Point(coordinates));\n    this.vertexFeature_ = vertexFeature;\n    this.overlay_.getSource().addFeature(vertexFeature);\n  } else {\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    geometry.setCoordinates(coordinates);\n  }\n  return vertexFeature;\n};\n\n\n/**\n * @param {ol.ModifySegmentDataType} a The first segment data.\n * @param {ol.ModifySegmentDataType} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Start drag sequence?\n * @this {ol.interaction.Modify}\n */\nfunction handleDownEvent(evt) {\n  if (!this.condition_(evt)) {\n    return false;\n  }\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n  const pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);\n  this.dragSegments_.length = 0;\n  this.modified_ = false;\n  const vertexFeature = this.vertexFeature_;\n  if (vertexFeature) {\n    const insertVertices = [];\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    const vertex = geometry.getCoordinates();\n    const vertexExtent = boundingExtent([vertex]);\n    const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n    const componentSegments = {};\n    segmentDataMatches.sort(compareIndexes);\n    for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n      const segmentDataMatch = segmentDataMatches[i];\n      const segment = segmentDataMatch.segment;\n      let uid = getUid(segmentDataMatch.feature);\n      const depth = segmentDataMatch.depth;\n      if (depth) {\n        uid += '-' + depth.join('-'); // separate feature components\n      }\n      if (!componentSegments[uid]) {\n        componentSegments[uid] = new Array(2);\n      }\n      if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE &&\n      segmentDataMatch.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n\n        const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);\n        if (coordinatesEqual(closestVertex, vertex) && !componentSegments[uid][0]) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n        }\n      } else if (coordinatesEqual(segment[0], vertex) &&\n          !componentSegments[uid][0]) {\n        this.dragSegments_.push([segmentDataMatch, 0]);\n        componentSegments[uid][0] = segmentDataMatch;\n      } else if (coordinatesEqual(segment[1], vertex) &&\n          !componentSegments[uid][1]) {\n\n        // prevent dragging closed linestrings by the connecting node\n        if ((segmentDataMatch.geometry.getType() ===\n            GeometryType.LINE_STRING ||\n            segmentDataMatch.geometry.getType() ===\n            GeometryType.MULTI_LINE_STRING) &&\n            componentSegments[uid][0] &&\n            componentSegments[uid][0].index === 0) {\n          continue;\n        }\n\n        this.dragSegments_.push([segmentDataMatch, 1]);\n        componentSegments[uid][1] = segmentDataMatch;\n      } else if (this.insertVertexCondition_(evt) && getUid(segment) in this.vertexSegments_ &&\n          (!componentSegments[uid][0] && !componentSegments[uid][1])) {\n        insertVertices.push([segmentDataMatch, vertex]);\n      }\n    }\n    if (insertVertices.length) {\n      this.willModifyFeatures_(evt);\n    }\n    for (let j = insertVertices.length - 1; j >= 0; --j) {\n      this.insertVertex_.apply(this, insertVertices[j]);\n    }\n  }\n  return !!this.vertexFeature_;\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @this {ol.interaction.Modify}\n */\nfunction handleDragEvent(evt) {\n  this.ignoreNextSingleClick_ = false;\n  this.willModifyFeatures_(evt);\n\n  const vertex = evt.coordinate;\n  for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n    const dragSegment = this.dragSegments_[i];\n    const segmentData = dragSegment[0];\n    const depth = segmentData.depth;\n    const geometry = segmentData.geometry;\n    let coordinates;\n    const segment = segmentData.segment;\n    const index = dragSegment[1];\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(segment[index][vertex.length]);\n    }\n\n    switch (geometry.getType()) {\n      case GeometryType.POINT:\n        coordinates = vertex;\n        segment[0] = segment[1] = vertex;\n        break;\n      case GeometryType.MULTI_POINT:\n        coordinates = geometry.getCoordinates();\n        coordinates[segmentData.index] = vertex;\n        segment[0] = segment[1] = vertex;\n        break;\n      case GeometryType.LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates[segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.MULTI_LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.MULTI_POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.CIRCLE:\n        segment[0] = segment[1] = vertex;\n        if (segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX) {\n          this.changingFeature_ = true;\n          geometry.setCenter(vertex);\n          this.changingFeature_ = false;\n        } else { // We're dragging the circle's circumference:\n          this.changingFeature_ = true;\n          geometry.setRadius(coordinateDistance(geometry.getCenter(), vertex));\n          this.changingFeature_ = false;\n        }\n        break;\n      default:\n        // pass\n    }\n\n    if (coordinates) {\n      this.setGeometryCoordinates_(geometry, coordinates);\n    }\n  }\n  this.createOrUpdateVertexFeature_(vertex);\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {ol.interaction.Modify}\n */\nfunction handleUpEvent(evt) {\n  let segmentData;\n  let geometry;\n  for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n    segmentData = this.dragSegments_[i][0];\n    geometry = segmentData.geometry;\n    if (geometry.getType() === GeometryType.CIRCLE) {\n      // Update a circle object in the R* bush:\n      const coordinates = geometry.getCenter();\n      const centerSegmentData = segmentData.featureSegments[0];\n      const circumferenceSegmentData = segmentData.featureSegments[1];\n      centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;\n      circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;\n      this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n      this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);\n    } else {\n      this.rBush_.update(boundingExtent(segmentData.segment),\n        segmentData);\n    }\n  }\n  if (this.modified_) {\n    this.dispatchEvent(new Modify.Event(\n      ModifyEventType.MODIFYEND, this.features_, evt));\n    this.modified_ = false;\n  }\n  return false;\n}\n\n\n/**\n * Handles the {@link ol.MapBrowserEvent map browser event} and may modify the\n * geometry.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {ol.interaction.Modify}\n */\nfunction handleEvent(mapBrowserEvent) {\n  if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {\n    return true;\n  }\n  this.lastPointerEvent_ = mapBrowserEvent;\n\n  let handled;\n  if (!mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence) {\n    this.handlePointerMove_(mapBrowserEvent);\n  }\n  if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n    if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {\n      handled = this.removePoint();\n    } else {\n      handled = true;\n    }\n  }\n\n  if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n    this.ignoreNextSingleClick_ = false;\n  }\n\n  return handlePointerEvent.call(this, mapBrowserEvent) && !handled;\n}\n\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @private\n */\nModify.prototype.handlePointerMove_ = function(evt) {\n  this.lastPixel_ = evt.pixel;\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n};\n\n\n/**\n * @param {ol.Pixel} pixel Pixel\n * @param {ol.PluggableMap} map Map.\n * @private\n */\nModify.prototype.handlePointerAtPixel_ = function(pixel, map) {\n  const pixelCoordinate = map.getCoordinateFromPixel(pixel);\n  const sortByDistance = function(a, b) {\n    return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -\n        pointDistanceToSegmentDataSquared(pixelCoordinate, b);\n  };\n\n  const box = buffer(createOrUpdateFromCoordinate(pixelCoordinate),\n    map.getView().getResolution() * this.pixelTolerance_);\n\n  const rBush = this.rBush_;\n  const nodes = rBush.getInExtent(box);\n  if (nodes.length > 0) {\n    nodes.sort(sortByDistance);\n    const node = nodes[0];\n    const closestSegment = node.segment;\n    let vertex = closestOnSegmentData(pixelCoordinate, node);\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\n    let dist = coordinateDistance(pixel, vertexPixel);\n    if (dist <= this.pixelTolerance_) {\n      const vertexSegments = {};\n\n      if (node.geometry.getType() === GeometryType.CIRCLE &&\n      node.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n\n        this.snappedToVertex_ = true;\n        this.createOrUpdateVertexFeature_(vertex);\n      } else {\n        const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        this.createOrUpdateVertexFeature_(vertex);\n        let segment;\n        for (let i = 1, ii = nodes.length; i < ii; ++i) {\n          segment = nodes[i].segment;\n          if ((coordinatesEqual(closestSegment[0], segment[0]) &&\n              coordinatesEqual(closestSegment[1], segment[1]) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n              coordinatesEqual(closestSegment[1], segment[0])))) {\n            vertexSegments[getUid(segment)] = true;\n          } else {\n            break;\n          }\n        }\n      }\n\n      vertexSegments[getUid(closestSegment)] = true;\n      this.vertexSegments_ = vertexSegments;\n      return;\n    }\n  }\n  if (this.vertexFeature_) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n};\n\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {ol.Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === GeometryType.CIRCLE) {\n    const circleGeometry = /** @type {ol.geom.Circle} */ (geometry);\n\n    if (segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n      const distanceToCenterSquared =\n            squaredCoordinateDistance(circleGeometry.getCenter(), pointCoordinates);\n      const distanceToCircumference =\n            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n  return squaredDistanceToSegment(pointCoordinates, segmentData.segment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {ol.Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @return {ol.Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === GeometryType.CIRCLE &&\n  segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n    return geometry.getClosestPoint(pointCoordinates);\n  }\n  return closestOnSegment(pointCoordinates, segmentData.segment);\n}\n\n\n/**\n * @param {ol.ModifySegmentDataType} segmentData Segment data.\n * @param {ol.Coordinate} vertex Vertex.\n * @private\n */\nModify.prototype.insertVertex_ = function(segmentData, vertex) {\n  const segment = segmentData.segment;\n  const feature = segmentData.feature;\n  const geometry = segmentData.geometry;\n  const depth = segmentData.depth;\n  const index = /** @type {number} */ (segmentData.index);\n  let coordinates;\n\n  while (vertex.length < geometry.getStride()) {\n    vertex.push(0);\n  }\n\n  switch (geometry.getType()) {\n    case GeometryType.MULTI_LINE_STRING:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.POLYGON:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.MULTI_POLYGON:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.LINE_STRING:\n      coordinates = geometry.getCoordinates();\n      coordinates.splice(index + 1, 0, vertex);\n      break;\n    default:\n      return;\n  }\n\n  this.setGeometryCoordinates_(geometry, coordinates);\n  const rTree = this.rBush_;\n  rTree.remove(segmentData);\n  this.updateSegmentIndices_(geometry, index, depth, 1);\n  const newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    segment: [segment[0], vertex],\n    feature: feature,\n    geometry: geometry,\n    depth: depth,\n    index: index\n  });\n  rTree.insert(boundingExtent(newSegmentData.segment),\n    newSegmentData);\n  this.dragSegments_.push([newSegmentData, 1]);\n\n  const newSegmentData2 = /** @type {ol.ModifySegmentDataType} */ ({\n    segment: [vertex, segment[1]],\n    feature: feature,\n    geometry: geometry,\n    depth: depth,\n    index: index + 1\n  });\n  rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n  this.dragSegments_.push([newSegmentData2, 0]);\n  this.ignoreNextSingleClick_ = true;\n};\n\n/**\n * Removes the vertex currently being pointed.\n * @return {boolean} True when a vertex was removed.\n * @api\n */\nModify.prototype.removePoint = function() {\n  if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {\n    const evt = this.lastPointerEvent_;\n    this.willModifyFeatures_(evt);\n    this.removeVertex_();\n    this.dispatchEvent(new Modify.Event(ModifyEventType.MODIFYEND, this.features_, evt));\n    this.modified_ = false;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes a vertex from all matching features.\n * @return {boolean} True when a vertex was removed.\n * @private\n */\nModify.prototype.removeVertex_ = function() {\n  const dragSegments = this.dragSegments_;\n  const segmentsByFeature = {};\n  let deleted = false;\n  let component, coordinates, dragSegment, geometry, i, index, left;\n  let newIndex, right, segmentData, uid;\n  for (i = dragSegments.length - 1; i >= 0; --i) {\n    dragSegment = dragSegments[i];\n    segmentData = dragSegment[0];\n    uid = getUid(segmentData.feature);\n    if (segmentData.depth) {\n      // separate feature components\n      uid += '-' + segmentData.depth.join('-');\n    }\n    if (!(uid in segmentsByFeature)) {\n      segmentsByFeature[uid] = {};\n    }\n    if (dragSegment[1] === 0) {\n      segmentsByFeature[uid].right = segmentData;\n      segmentsByFeature[uid].index = segmentData.index;\n    } else if (dragSegment[1] == 1) {\n      segmentsByFeature[uid].left = segmentData;\n      segmentsByFeature[uid].index = segmentData.index + 1;\n    }\n\n  }\n  for (uid in segmentsByFeature) {\n    right = segmentsByFeature[uid].right;\n    left = segmentsByFeature[uid].left;\n    index = segmentsByFeature[uid].index;\n    newIndex = index - 1;\n    if (left !== undefined) {\n      segmentData = left;\n    } else {\n      segmentData = right;\n    }\n    if (newIndex < 0) {\n      newIndex = 0;\n    }\n    geometry = segmentData.geometry;\n    coordinates = geometry.getCoordinates();\n    component = coordinates;\n    deleted = false;\n    switch (geometry.getType()) {\n      case GeometryType.MULTI_LINE_STRING:\n        if (coordinates[segmentData.depth[0]].length > 2) {\n          coordinates[segmentData.depth[0]].splice(index, 1);\n          deleted = true;\n        }\n        break;\n      case GeometryType.LINE_STRING:\n        if (coordinates.length > 2) {\n          coordinates.splice(index, 1);\n          deleted = true;\n        }\n        break;\n      case GeometryType.MULTI_POLYGON:\n        component = component[segmentData.depth[1]];\n        /* falls through */\n      case GeometryType.POLYGON:\n        component = component[segmentData.depth[0]];\n        if (component.length > 4) {\n          if (index == component.length - 1) {\n            index = 0;\n          }\n          component.splice(index, 1);\n          deleted = true;\n          if (index === 0) {\n            // close the ring again\n            component.pop();\n            component.push(component[0]);\n            newIndex = component.length - 1;\n          }\n        }\n        break;\n      default:\n        // pass\n    }\n\n    if (deleted) {\n      this.setGeometryCoordinates_(geometry, coordinates);\n      const segments = [];\n      if (left !== undefined) {\n        this.rBush_.remove(left);\n        segments.push(left.segment[0]);\n      }\n      if (right !== undefined) {\n        this.rBush_.remove(right);\n        segments.push(right.segment[1]);\n      }\n      if (left !== undefined && right !== undefined) {\n        const newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          depth: segmentData.depth,\n          feature: segmentData.feature,\n          geometry: segmentData.geometry,\n          index: newIndex,\n          segment: segments\n        });\n        this.rBush_.insert(boundingExtent(newSegmentData.segment),\n          newSegmentData);\n      }\n      this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n      if (this.vertexFeature_) {\n        this.overlay_.getSource().removeFeature(this.vertexFeature_);\n        this.vertexFeature_ = null;\n      }\n      dragSegments.length = 0;\n    }\n\n  }\n  return deleted;\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} geometry Geometry.\n * @param {Array} coordinates Coordinates.\n * @private\n */\nModify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {\n  this.changingFeature_ = true;\n  geometry.setCoordinates(coordinates);\n  this.changingFeature_ = false;\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} geometry Geometry.\n * @param {number} index Index.\n * @param {Array.<number>|undefined} depth Depth.\n * @param {number} delta Delta (1 or -1).\n * @private\n */\nModify.prototype.updateSegmentIndices_ = function(\n  geometry, index, depth, delta) {\n  this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {\n    if (segmentDataMatch.geometry === geometry &&\n        (depth === undefined || segmentDataMatch.depth === undefined ||\n        equals(segmentDataMatch.depth, depth)) &&\n        segmentDataMatch.index > index) {\n      segmentDataMatch.index += delta;\n    }\n  });\n};\n\n\n/**\n * @return {ol.StyleFunction} Styles.\n */\nModify.getDefaultStyleFunction = function() {\n  const style = Style.createDefaultEditing();\n  return function(feature, resolution) {\n    return style[GeometryType.POINT];\n  };\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link ol.interaction.Modify} instances are instances of\n * this type.\n *\n * @constructor\n * @extends {ol.events.Event}\n * @implements {oli.ModifyEvent}\n * @param {ol.interaction.ModifyEventType} type Type.\n * @param {ol.Collection.<ol.Feature>} features The features modified.\n * @param {ol.MapBrowserPointerEvent} mapBrowserPointerEvent Associated\n *     {@link ol.MapBrowserPointerEvent}.\n */\nModify.Event = function(type, features, mapBrowserPointerEvent) {\n\n  Event.call(this, type);\n\n  /**\n   * The features being modified.\n   * @type {ol.Collection.<ol.Feature>}\n   * @api\n   */\n  this.features = features;\n\n  /**\n   * Associated {@link ol.MapBrowserEvent}.\n   * @type {ol.MapBrowserEvent}\n   * @api\n   */\n  this.mapBrowserEvent = mapBrowserPointerEvent;\n};\n\ninherits(Modify.Event, Event);\n\nexport default Modify;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/interaction/Modify.js\n// module id = null\n// module chunks = ","/**\n * @module ol/source/OSM\n */\nimport {inherits} from '../index.js';\nimport XYZ from '../source/XYZ.js';\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n *\n * @constructor\n * @extends {ol.source.XYZ}\n * @param {olx.source.OSMOptions=} opt_options Open Street Map options.\n * @api\n */\nconst OSM = function(opt_options) {\n\n  const options = opt_options || {};\n\n  let attributions;\n  if (options.attributions !== undefined) {\n    attributions = options.attributions;\n  } else {\n    attributions = [OSM.ATTRIBUTION];\n  }\n\n  const crossOrigin = options.crossOrigin !== undefined ?\n    options.crossOrigin : 'anonymous';\n\n  const url = options.url !== undefined ?\n    options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n  XYZ.call(this, {\n    attributions: attributions,\n    cacheSize: options.cacheSize,\n    crossOrigin: crossOrigin,\n    opaque: options.opaque !== undefined ? options.opaque : true,\n    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n    tileLoadFunction: options.tileLoadFunction,\n    url: url,\n    wrapX: options.wrapX\n  });\n\n};\n\ninherits(OSM, XYZ);\n\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nOSM.ATTRIBUTION = '&copy; ' +\n      '<a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> ' +\n      'contributors.';\nexport default OSM;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/source/OSM.js\n// module id = 4\n// module chunks = 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26","/**\n * @module app.modifyrectangle\n */\nconst exports = {};\n\nimport './modifyrectangle.css';\nimport './common_dependencies.js';\nimport ngeoInteractionModifyRectangle from 'ngeo/interaction/ModifyRectangle.js';\n\nimport olMap from 'ol/Map.js';\nimport olView from 'ol/View.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olSourceOSM from 'ol/source/OSM.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olGeomPolygon from 'ol/geom/Polygon.js';\nimport olCollection from 'ol/Collection.js';\nimport olFeature from 'ol/Feature.js';\nimport olStyleStyle from 'ol/style/Style.js';\nimport olStyleCircle from 'ol/style/Circle.js';\nimport olStyleFill from 'ol/style/Fill.js';\nimport olStyleStroke from 'ol/style/Stroke.js';\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n\n/** @type {!angular.Module} **/\nconst module = angular.module('app', [\n  ngeoMapModule.name\n]);\n\n\n/**\n * @constructor\n * @ngInject\n */\nexports.MainController = function() {\n\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map = new olMap({\n    layers: [\n      new olLayerTile({\n        source: new olSourceOSM()\n      })\n    ],\n    view: new olView({\n      center: [-10997148, 4569099],\n      zoom: 4\n    })\n  });\n\n  const map = this.map;\n\n  const rectangle = new olGeomPolygon([[\n    [-9e6, 4e6], [-11e6, 4e6], [-11e6, 6e6], [-9e6, 6e6]\n  ]]);\n\n  /**\n   * @type {ol.Collection.<ol.Feature>}\n   * @export\n   */\n  this.features = new olCollection();\n\n  this.features.push(new olFeature({\n    geometry: rectangle,\n    'isRectangle': true\n  }));\n\n  const style = (function() {\n    const styles = {};\n    styles['Polygon'] = [\n      new olStyleStyle({\n        fill: new olStyleFill({\n          color: [255, 255, 255, 0.5]\n        })\n      }),\n      new olStyleStyle({\n        stroke: new olStyleStroke({\n          color: [255, 255, 255, 1],\n          width: 5\n        })\n      }),\n      new olStyleStyle({\n        stroke: new olStyleStroke({\n          color: [0, 153, 255, 1],\n          width: 3\n        })\n      })\n    ];\n\n    styles['Point'] = [\n      new olStyleStyle({\n        image: new olStyleCircle({\n          radius: 7,\n          fill: new olStyleFill({\n            color: [0, 153, 255, 1]\n          }),\n          stroke: new olStyleStroke({\n            color: [255, 255, 255, 0.75],\n            width: 1.5\n          })\n        }),\n        zIndex: 100000\n      })\n    ];\n    styles['GeometryCollection'] = styles['Polygon'].concat(styles['Point']);\n\n    return function(feature, resolution) {\n      return styles[feature.getGeometry().getType()];\n    };\n  })();\n\n  const vectorSource = new olSourceVector({\n    features: this.features\n  });\n  const vectorLayer = new olLayerVector({\n    source: vectorSource\n  });\n\n  // Use vectorLayer.setMap(map) rather than map.addLayer(vectorLayer). This\n  // makes the vector layer \"unmanaged\", meaning that it is always on top.\n  vectorLayer.setMap(map);\n\n  /**\n   * @type {ngeo.interaction.ModifyRectangle}\n   * @export\n   */\n  this.interaction = new ngeoInteractionModifyRectangle(\n    /** @type {olx.interaction.ModifyOptions} */({\n      features: this.features,\n      style: style\n    }));\n\n  const interaction = this.interaction;\n  map.addInteraction(interaction);\n  interaction.setActive(true);\n\n};\n\n\nmodule.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./examples/modifyrectangle.js","/**\n * @module ngeo.interaction.ModifyRectangle\n */\nimport googAsserts from 'goog/asserts.js';\nimport * as olBase from 'ol/index.js';\nimport olFeature from 'ol/Feature.js';\nimport * as olEvents from 'ol/events.js';\nimport olGeomPoint from 'ol/geom/Point.js';\nimport olGeomPolygon from 'ol/geom/Polygon.js';\nimport olInteractionModify from 'ol/interaction/Modify.js';\nimport olInteractionPointer from 'ol/interaction/Pointer.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olSourceVector from 'ol/source/Vector.js';\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.\n *\n * @constructor\n * @struct\n * @extends {ol.interaction.Pointer}\n * @param {olx.interaction.ModifyOptions} options Options.\n * @fires ngeo.interaction.ModifyCircleEvent\n * @api\n */\nconst exports = function(options) {\n\n  googAsserts.assert(options.features);\n\n  olInteractionPointer.call(this, {\n    handleDownEvent: this.handleDown_,\n    handleDragEvent: this.handleDrag_,\n    handleUpEvent: this.handleUp_\n  });\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.modified_ = false;\n\n  // Get the style for the box and the points\n  const style = options.style ? options.style : olInteractionModify.getDefaultStyleFunction();\n\n  /**\n   * @type {ol.layer.Vector}\n   * @private\n   */\n  this.vectorPoints_ = new olLayerVector({\n    source: new olSourceVector({\n      wrapX: !!options.wrapX\n    }),\n    visible: this.getActive(),\n    style: style,\n    updateWhileAnimating: true,\n    updateWhileInteracting: true\n  });\n\n  /**\n   * @type {!ol.Collection.<ol.Feature>}\n   * @private\n   */\n  this.features_ = options.features;\n\n  /**\n   * The feature currently modified.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.feature_ = null;\n\n  /**\n   * @type {Object.<number, ngeo.interaction.ModifyRectangle.CacheItem>}\n   * @private\n   */\n  this.cache_ = {};\n\n  /**\n   * @type {?ngeo.interaction.ModifyRectangle.ModifyParams}\n   * @private\n   */\n  this.params_ = null;\n\n  olEvents.listen(this.features_, 'add', this.handleFeatureAdd_, this);\n  olEvents.listen(this.features_, 'remove', this.handleFeatureRemove_, this);\n\n  this.features_.forEach(this.addFeature_, this);\n\n};\n\nolBase.inherits(exports, olInteractionPointer);\n\n\n/**\n * @param {boolean} active Active.\n * @override\n */\nexports.prototype.setActive = function(active) {\n  olInteractionPointer.prototype.setActive.call(this, active);\n  if (this.vectorPoints_) {\n    this.vectorPoints_.setVisible(active);\n  }\n};\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.prototype.addFeature_ = function(feature) {\n  const featureGeom = feature.getGeometry();\n  if (featureGeom instanceof olGeomPolygon) {\n\n    // If the feature's corners are already set, no need to set them again\n    const uid = olBase.getUid(feature);\n    let item = this.cache_[uid];\n    if (item) {\n      return;\n    }\n\n    const pointSource = this.vectorPoints_.getSource();\n\n    // from each corners, create a point feature and add it to the point layer.\n    // each point is then associated with 2 siblings in order to update the\n    // siblings geometry at the same time when a point gets dragged around.\n    // mark each one as 'corner'\n    const corners = featureGeom.getCoordinates()[0];\n    while (corners.length > 4) {\n      if (corners[0][0] < corners[1][0] && corners[0][1] <= corners[1][1]) {\n        corners.pop();\n      } else {\n        corners.shift();\n      }\n    }\n    const pointFeatures = [];\n    let cornerPoint;\n    let cornerFeature;\n    corners.forEach((corner) => {\n      cornerPoint = new olGeomPoint(corner);\n      cornerFeature = new olFeature({\n        'corner': true,\n        'geometry': cornerPoint,\n        'siblingX': null,\n        'siblingY': null,\n        'boxFeature': feature\n      });\n\n      pointFeatures.push(cornerFeature);\n    }, this);\n    item = /** @type {ngeo.interaction.ModifyRectangle.CacheItem} */ ({\n      corners: pointFeatures\n    });\n    this.cache_[uid] = item;\n\n    let previousFeature;\n    let nextFeature;\n    pointFeatures.forEach((cornerFeature, index) => {\n      previousFeature = pointFeatures[index - 1];\n      if (!previousFeature) {\n        previousFeature = pointFeatures[pointFeatures.length - 1];\n      }\n\n      nextFeature = pointFeatures[index + 1];\n      if (!nextFeature) {\n        nextFeature = pointFeatures[0];\n      }\n\n      if (index % 2 === 0) {\n        cornerFeature.set('siblingX', nextFeature);\n        cornerFeature.set('siblingY', previousFeature);\n      } else {\n        cornerFeature.set('siblingX', previousFeature);\n        cornerFeature.set('siblingY', nextFeature);\n      }\n\n    }, this);\n    pointSource.addFeatures(pointFeatures);\n  }\n\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Map browser event\n * @private\n */\nexports.prototype.willModifyFeatures_ = function(evt) {\n  if (!this.modified_) {\n    this.modified_ = true;\n    this.dispatchEvent(new olInteractionModify.Event(\n      /** @type {ol.interaction.ModifyEventType} */ ('modifystart'), this.features_, evt));\n    this.params_ = this.initializeParams_();\n  }\n};\n\n\n/**\n * @return {ngeo.interaction.ModifyRectangle.ModifyParams} The initialised params\n * @private\n */\nexports.prototype.initializeParams_ = function() {\n  const feature = this.feature_;\n\n  // 1. Find the origin (opposite) point for the modify operation\n  // siblingY relative to the origin is siblingX relative to the opposite\n  const siblingY = feature.get('siblingX');\n  googAsserts.assertInstanceof(siblingY, olFeature);\n\n  const origin = siblingY.get('siblingY');\n  googAsserts.assertInstanceof(origin, olFeature);\n  const originPoint = origin.getGeometry();\n  googAsserts.assertInstanceof(originPoint, olGeomPoint);\n  const originCoordinate = originPoint.getCoordinates();\n  const originPixel = this.getMap().getPixelFromCoordinate(originCoordinate);\n\n  // 2. Find the origin's X sibling and the normal vector from the origin to it\n  const siblingX = origin.get('siblingX');\n  googAsserts.assertInstanceof(siblingX, olFeature);\n  const siblingXPoint = siblingX.getGeometry();\n  googAsserts.assertInstanceof(siblingXPoint, olGeomPoint);\n  const siblingXCoordinate = siblingXPoint.getCoordinates();\n  const siblingXPixel = this.getMap().getPixelFromCoordinate(siblingXCoordinate);\n  let vectorX = [\n    siblingXPixel[0] - originPixel[0],\n    siblingXPixel[1] - originPixel[1]\n  ];\n  const vectorXMagnitude = Math.sqrt(vectorX[0] * vectorX[0] + vectorX[1] * vectorX[1]);\n  vectorX[0] /= vectorXMagnitude;\n  vectorX[1] /= vectorXMagnitude;\n\n  // 3. Find the origin's Y sibling and the normal vector from the origin to it\n  const siblingYPoint = siblingY.getGeometry();\n  googAsserts.assertInstanceof(siblingYPoint, olGeomPoint);\n  const siblingYCoordinate = siblingYPoint.getCoordinates();\n  const siblingYPixel = this.getMap().getPixelFromCoordinate(siblingYCoordinate);\n  let vectorY = [\n    siblingYPixel[0] - originPixel[0],\n    siblingYPixel[1] - originPixel[1]\n  ];\n  const vectorYMagnitude = Math.sqrt(vectorY[0] * vectorY[0] + vectorY[1] * vectorY[1]);\n  vectorY[0] /= vectorYMagnitude;\n  vectorY[1] /= vectorYMagnitude;\n\n  // 4. Validate the vectors.\n  if (isNaN(vectorX[0]) && isNaN(vectorY[0])) {\n    // Both vector are invalid. Rotation information has already been lost\n    vectorX = [0, 1];\n    vectorY = [1, 0];\n  } else if (isNaN(vectorX[0])) {\n    vectorX = [vectorY[1], -vectorY[0]];\n  } else if (isNaN(vectorY[0])) {\n    vectorY = [vectorX[1], -vectorX[0]];\n  }\n\n  return {\n    originCoordinate,\n    originPixel,\n    siblingXPoint,\n    siblingYPoint,\n    vectorX,\n    vectorY\n  };\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.prototype.removeFeature_ = function(feature) {\n  const uid = olBase.getUid(feature);\n  const item = this.cache_[uid];\n  const corners = item.corners;\n  for (let i = 0; i < corners.length; i++) {\n    this.vectorPoints_.getSource().removeFeature(corners[i]);\n  }\n  this.feature_ = null;\n  corners.length = 0;\n  delete this.cache_[uid];\n};\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.setMap = function(map) {\n  this.vectorPoints_.setMap(map);\n  olInteractionPointer.prototype.setMap.call(this, map);\n};\n\n\n/**\n * @param {ol.Collection.Event} evt Event.\n * @private\n */\nexports.prototype.handleFeatureAdd_ = function(evt) {\n  const feature = evt.element;\n  googAsserts.assertInstanceof(feature, olFeature,\n    'feature should be an ol.Feature');\n  this.addFeature_(feature);\n};\n\n\n/**\n * @param {ol.Collection.Event} evt Event.\n * @private\n */\nexports.prototype.handleFeatureRemove_ = function(evt) {\n  const feature = /** @type {ol.Feature} */ (evt.element);\n  this.removeFeature_(feature);\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Start drag sequence?\n * @this {ngeo.interaction.ModifyRectangle}\n * @private\n */\nexports.prototype.handleDown_ = function(evt) {\n  const map = evt.map;\n\n  const feature = map.forEachFeatureAtPixel(evt.pixel, feature =>\n    (feature.get('siblingX') && feature.get('siblingY') ? feature : undefined)\n  );\n\n  if (feature) {\n    this.feature_ = feature;\n\n    return true;\n  }\n\n  return false;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @this {ngeo.interaction.ModifyRectangle}\n * @private\n */\nexports.prototype.handleDrag_ = function(evt) {\n  this.willModifyFeatures_(evt);\n  const feature = this.feature_;\n\n  const geometry = /** @type {ol.geom.SimpleGeometry} */\n      (feature.getGeometry());\n\n  if (geometry instanceof olGeomPoint) {\n    geometry.setCoordinates(evt.coordinate);\n\n    const destinationPixel = evt.pixel;\n\n    const originPixel = this.params_.originPixel;\n    const siblingXPoint = this.params_.siblingXPoint;\n    const siblingYPoint = this.params_.siblingYPoint;\n    const vectorX = this.params_.vectorX;\n    const vectorY = this.params_.vectorY;\n    const originCoordinate = this.params_.originCoordinate;\n\n    // Calculate new positions of siblings\n    const b2Pixel = this.calculateNewPixel_(\n      originPixel, destinationPixel, vectorX);\n    const b2Coordinate = this.getMap().getCoordinateFromPixel(b2Pixel);\n    siblingXPoint.setCoordinates(b2Coordinate);\n\n    const c2Pixel = this.calculateNewPixel_(\n      originPixel, destinationPixel, vectorY);\n    const c2Coordinate = this.getMap().getCoordinateFromPixel(c2Pixel);\n    siblingYPoint.setCoordinates(c2Coordinate);\n\n\n    // Resize the box\n    const boxFeature = feature.get('boxFeature');\n    const geom = boxFeature.getGeometry();\n    googAsserts.assertInstanceof(geom, olGeomPolygon);\n    geom.setCoordinates([[evt.coordinate, b2Coordinate, originCoordinate, c2Coordinate, evt.coordinate]]);\n  }\n};\n\n\n/**\n * Calculate the new position of a point as projected on a vector from origin to\n * destination.\n * @param {ol.Pixel} origin Pixel of origin (opposite of the drag handle)\n * @param {ol.Pixel} destination Pixel of destination (the handle we dragged)\n * @param {ol.Pixel} vector The normalized vector to the point\n * @return {ol.Pixel} The new pixel of the point\n * @private\n */\nexports.prototype.calculateNewPixel_ = function(\n  origin, destination, vector) {\n\n  const aVector = [destination[0] - origin[0], destination[1] - origin[1]];\n\n  const abScalarProduct = aVector[0] * vector[0] + aVector[1] * vector[1];\n\n  const deltaVector = [\n    (vector[0] * abScalarProduct),\n    (vector[1] * abScalarProduct)\n  ];\n\n  return [deltaVector[0] + origin[0], deltaVector[1] + origin[1]];\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {ngeo.interaction.ModifyRectangle}\n * @private\n */\nexports.prototype.handleUp_ = function(evt) {\n  if (this.modified_) {\n    this.dispatchEvent(new olInteractionModify.Event(\n      /** @type {ol.interaction.ModifyEventType} */ ('modifyend'), this.features_, evt));\n    this.params_ = null;\n    this.modified_ = false;\n  }\n  return false;\n};\n\n\n/**\n * @typedef {{\n *     corners: Array.<ol.Feature>\n * }}\n */\nexports.CacheItem;\n\n\n/**\n * @typedef {{\n *     originCoordinate: ol.Coordinate,\n *     originPixel: ol.Pixel,\n *     siblingXPoint: ol.geom.Point,\n *     siblingYPoint: ol.geom.Point,\n *     vectorX: Array.<number>,\n *     vectorY: Array.<number>\n * }}\n */\nexports.ModifyParams;\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/interaction/ModifyRectangle.js","/**\n * @module ol/source/XYZ\n */\nimport {inherits} from '../index.js';\nimport TileImage from '../source/TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case,\n * {@link ol.source.TileImage} can be used with a `tileUrlFunction`\n * such as:\n *\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *        coordinate[1] + '/' + coordinate[2] + '.png';\n *    }\n *\n *\n * @constructor\n * @extends {ol.source.TileImage}\n * @param {olx.source.XYZOptions=} opt_options XYZ options.\n * @api\n */\nconst XYZ = function(opt_options) {\n  const options = opt_options || {};\n  const projection = options.projection !== undefined ?\n    options.projection : 'EPSG:3857';\n\n  const tileGrid = options.tileGrid !== undefined ? options.tileGrid :\n    createXYZ({\n      extent: extentFromProjection(projection),\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize\n    });\n\n  TileImage.call(this, {\n    attributions: options.attributions,\n    cacheSize: options.cacheSize,\n    crossOrigin: options.crossOrigin,\n    opaque: options.opaque,\n    projection: projection,\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n    tileGrid: tileGrid,\n    tileLoadFunction: options.tileLoadFunction,\n    tilePixelRatio: options.tilePixelRatio,\n    tileUrlFunction: options.tileUrlFunction,\n    url: options.url,\n    urls: options.urls,\n    wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    transition: options.transition\n  });\n\n};\n\ninherits(XYZ, TileImage);\nexport default XYZ;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/source/XYZ.js\n// module id = 5\n// module chunks = 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26"],"sourceRoot":""}