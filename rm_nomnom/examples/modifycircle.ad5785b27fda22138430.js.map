{"version":3,"sources":["webpack:///./node_modules/openlayers/src/ol/interaction/ModifyEventType.js","webpack:///./node_modules/openlayers/src/ol/interaction/Modify.js","webpack:///./node_modules/openlayers/src/ol/source/OSM.js","webpack:///./examples/modifycircle.js","webpack:///./src/interaction/ModifyCircle.js","webpack:///./node_modules/openlayers/src/ol/source/XYZ.js"],"names":["ModifyEventType","MODIFYSTART","MODIFYEND","Modify","options","features","Pointer","call","this","handleDownEvent","handleDragEvent","handleEvent","handleUpEvent","condition_","condition","defaultDeleteCondition_","mapBrowserEvent","Object","deleteCondition_","deleteCondition","insertVertexCondition_","insertVertexCondition","vertexFeature_","vertexSegments_","lastPixel_","ignoreNextSingleClick_","modified_","rBush_","RBush","pixelTolerance_","undefined","pixelTolerance","snappedToVertex_","changingFeature_","dragSegments_","overlay_","Vector","source","source_Vector","useSpatialIndex","wrapX","style","getDefaultStyleFunction","updateWhileAnimating","updateWhileInteracting","SEGMENT_WRITERS_","Point","writePointGeometry_","LineString","writeLineStringGeometry_","LinearRing","Polygon","writePolygonGeometry_","MultiPoint","writeMultiPointGeometry_","MultiLineString","writeMultiLineStringGeometry_","MultiPolygon","writeMultiPolygonGeometry_","Circle","writeCircleGeometry_","GeometryCollection","writeGeometryCollectionGeometry_","source_","Collection","getFeatures","events","VectorEventType","ADDFEATURE","handleSourceAdd_","REMOVEFEATURE","handleSourceRemove_","Error","features_","forEach","addFeature_","bind","CollectionEventType","ADD","handleFeatureAdd_","REMOVE","handleFeatureRemove_","lastPointerEvent_","compareIndexes","a","b","index","evt","handlePointerAtPixel_","pixel","map","pixelCoordinate","getCoordinateFromPixel","length","vertexFeature","insertVertices","vertex","getGeometry","getCoordinates","vertexExtent","extent","segmentDataMatches","getInExtent","componentSegments","sort","i","ii","segmentDataMatch","segment","uid","ol","feature","depth","join","Array","geometry","getType","GeometryType","CIRCLE","MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX","closestVertex","closestOnSegmentData","coordinate","push","LINE_STRING","MULTI_LINE_STRING","willModifyFeatures_","j","insertVertex_","apply","dragSegment","segmentData","coordinates","getStride","POINT","MULTI_POINT","POLYGON","MULTI_POLYGON","MODIFY_SEGMENT_CIRCLE_CENTER_INDEX","setCenter","setRadius","getCenter","setGeometryCoordinates_","createOrUpdateVertexFeature_","centerSegmentData","featureSegments","circumferenceSegmentData","update","getExtent","dispatchEvent","Event","MapBrowserPointerEvent","handled","getView","getInteracting","type","MapBrowserEventType","POINTERMOVE","handlingDownUpSequence","handlePointerMove_","SINGLECLICK","removePoint","pointDistanceToSegmentDataSquared","pointCoordinates","circleGeometry","distanceToCenterSquared","distanceToCircumference","Math","sqrt","getRadius","getClosestPoint","prototype","getMap","isRendered","getActive","EventType","CHANGE","handleFeatureChange_","removeFeature_","removeFeatureSegmentData_","getLength","getSource","removeFeature","rBush","nodesToRemove","node","remove","setActive","active","setMap","event","insert","points","slice","lines","jj","rings","polygons","k","kk","geometries","getGeometriesArray","setCoordinates","Feature","addFeature","sortByDistance","box","getResolution","nodes","closestSegment","vertexPixel","getPixelFromCoordinate","dist","vertexSegments","pixel1","pixel2","squaredDist1","squaredDist2","min","splice","rTree","updateSegmentIndices_","newSegmentData","newSegmentData2","POINTERDRAG","removeVertex_","dragSegments","segmentsByFeature","component","left","newIndex","right","deleted","pop","segments","delta","forEachInExtent","array","Style","createDefaultEditing","resolution","mapBrowserPointerEvent","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_1__source_XYZ_js__","__webpack_require__","OSM","opt_options","attributions","ATTRIBUTION","crossOrigin","url","cacheSize","opaque","maxZoom","reprojectionErrorThreshold","tileLoadFunction","__WEBPACK_IMPORTED_MODULE_0__index_js__","exports","module","angular","_module3","default","name","MainController","_Map2","layers","_Tile2","_OSM2","view","_View2","center","zoom","circle","_Circle2","_Collection2","circleFeature","_Feature2","_Polygon2","fromCircle","color","label","opacity","stroke","set","_FeatureProperties2","IS_CIRCLE","vectorSource","_Vector4","_Vector2","interaction","_ModifyCircle2","addInteraction","controller","olBase","olCoordinate","olEvents","olExtent","_asserts2","assert","_Pointer2","handleDownEvent_","handleDragEvent_","handleUpEvent_","_RBush2","listen","inherits","get","_Modify2","element","assertInstanceof","boundingExtent","_Point2","compareIndexes_","getUid","equals","line","_LineString2","azimut","_MeasureAzimut2","getAzimut","getArray","AZIMUT","clear","lowerLeft","upperRight","squaredDistanceToSegment","closestOnSegment","squaredDistance","_Style2","__WEBPACK_IMPORTED_MODULE_2__tilegrid_js__","XYZ","projection","tileGrid","minZoom","tileSize","__WEBPACK_IMPORTED_MODULE_1__source_TileImage_js__","tilePixelRatio","tileUrlFunction","urls","transition"],"mappings":"+NAOAA,GAMAC,YAAA,cAMAC,UAAA,+DC0BA,MAAAC,EAAA,SAAAC,GAmJA,IAAAC,EAWA,GA5JAC,EAAA,QAAAC,KAAAC,MACAC,kBACAC,kBACAC,cACAC,kBAOAJ,KAAAK,WAAAT,EAAAU,UAAAV,EAAAU,YAAA,cAQAN,KAAAO,wBAAA,SAAAC,GACA,OAAAC,OAAAH,EAAA,WAAAG,CAAAD,IAAAC,OAAAH,EAAA,YAAAG,CAAAD,IAOAR,KAAAU,iBAAAd,EAAAe,gBACAf,EAAAe,gBAAAX,KAAAO,wBAMAP,KAAAY,uBAAAhB,EAAAiB,sBACAjB,EAAAiB,sBAAAP,EAAA,OAOAN,KAAAc,eAAA,KAOAd,KAAAe,gBAAA,KAMAf,KAAAgB,YAAA,KAQAhB,KAAAiB,wBAAA,EAMAjB,KAAAkB,WAAA,EAOAlB,KAAAmB,OAAA,IAAAC,EAAA,QAMApB,KAAAqB,qBAAAC,IAAA1B,EAAA2B,eACA3B,EAAA2B,eAAA,GAMAvB,KAAAwB,kBAAA,EAQAxB,KAAAyB,kBAAA,EAMAzB,KAAA0B,iBAOA1B,KAAA2B,SAAA,IAAAC,EAAA,SACAC,OAAA,IAAAC,EAAA,SACAC,iBAAA,EACAC,QAAApC,EAAAoC,QAEAC,MAAArC,EAAAqC,MAAArC,EAAAqC,MACAtC,EAAAuC,0BACAC,sBAAA,EACAC,wBAAA,IAQApC,KAAAqC,kBACAC,MAAAtC,KAAAuC,oBACAC,WAAAxC,KAAAyC,yBACAC,WAAA1C,KAAAyC,yBACAE,QAAA3C,KAAA4C,sBACAC,WAAA7C,KAAA8C,yBACAC,gBAAA/C,KAAAgD,8BACAC,aAAAjD,KAAAkD,2BACAC,OAAAnD,KAAAoD,qBACAC,mBAAArD,KAAAsD,kCAQAtD,KAAAuD,QAAA,KAGA3D,EAAAiC,QACA7B,KAAAuD,QAAA3D,EAAAiC,OACAhC,EAAA,IAAA2D,EAAA,QAAAxD,KAAAuD,QAAAE,eACAhD,OAAAiD,EAAA,OAAAjD,CAAAT,KAAAuD,QAAAI,EAAA,EAAAC,WACA5D,KAAA6D,iBAAA7D,MACAS,OAAAiD,EAAA,OAAAjD,CAAAT,KAAAuD,QAAAI,EAAA,EAAAG,cACA9D,KAAA+D,oBAAA/D,OAEAH,EAAAD,EAAAC,UAEAA,EACA,UAAAmE,MAAA,wDAOAhE,KAAAiE,UAAApE,EAEAG,KAAAiE,UAAAC,QAAAlE,KAAAmE,YAAAC,KAAApE,OACAS,OAAAiD,EAAA,OAAAjD,CAAAT,KAAAiE,UAAAI,EAAA,EAAAC,IACAtE,KAAAuE,kBAAAvE,MACAS,OAAAiD,EAAA,OAAAjD,CAAAT,KAAAiE,UAAAI,EAAA,EAAAG,OACAxE,KAAAyE,qBAAAzE,MAMAA,KAAA0E,kBAAA,MAmXA,SAAAC,EAAAC,EAAAC,GACA,OAAAD,EAAAE,MAAAD,EAAAC,MASA,SAAA7E,EAAA8E,GACA,IAAA/E,KAAAK,WAAA0E,GACA,SAEA/E,KAAAgF,sBAAAD,EAAAE,MAAAF,EAAAG,KACA,MAAAC,EAAAJ,EAAAG,IAAAE,uBAAAL,EAAAE,OACAjF,KAAA0B,cAAA2D,OAAA,EACArF,KAAAkB,WAAA,EACA,MAAAoE,EAAAtF,KAAAc,eACA,GAAAwE,EAAA,CACA,MAAAC,KAEAC,EAD8CF,EAAAG,cAC9CC,iBACAC,EAAAlF,OAAAmF,EAAA,eAAAnF,EAAA+E,IACAK,EAAA7F,KAAAmB,OAAA2E,YAAAH,GACAI,KACAF,EAAAG,KAAArB,GACA,QAAAsB,EAAA,EAAAC,EAAAL,EAAAR,OAAmDY,EAAAC,IAAQD,EAAA,CAC3D,MAAAE,EAAAN,EAAAI,GACAG,EAAAD,EAAAC,QACA,IAAAC,EAAA5F,OAAA6F,EAAA,OAAA7F,CAAA0F,EAAAI,SACA,MAAAC,EAAAL,EAAAK,MAOA,GANAA,IACAH,GAAA,IAAAG,EAAAC,KAAA,MAEAV,EAAAM,KACAN,EAAAM,GAAA,IAAAK,MAAA,IAEAP,EAAAQ,SAAAC,YAAAC,EAAA,EAAAC,QACAX,EAAArB,QAAAnF,EAAAoH,0CAAA,CAEA,MAAAC,EAAAC,EAAA9B,EAAAgB,GACA1F,OAAAyG,EAAA,OAAAzG,CAAAuG,EAAAxB,KAAAO,EAAAM,GAAA,KACArG,KAAA0B,cAAAyF,MAAAhB,EAAA,IACAJ,EAAAM,GAAA,GAAAF,QAEO,GAAA1F,OAAAyG,EAAA,OAAAzG,CAAA2F,EAAA,GAAAZ,KACPO,EAAAM,GAAA,GACArG,KAAA0B,cAAAyF,MAAAhB,EAAA,IACAJ,EAAAM,GAAA,GAAAF,OACO,GAAA1F,OAAAyG,EAAA,OAAAzG,CAAA2F,EAAA,GAAAZ,KACPO,EAAAM,GAAA,IAGA,IAAAF,EAAAQ,SAAAC,YACAC,EAAA,EAAAO,aACAjB,EAAAQ,SAAAC,YACAC,EAAA,EAAAQ,oBACAtB,EAAAM,GAAA,IACA,IAAAN,EAAAM,GAAA,GAAAvB,MACA,SAGA9E,KAAA0B,cAAAyF,MAAAhB,EAAA,IACAJ,EAAAM,GAAA,GAAAF,OACOnG,KAAAY,uBAAAmE,IAAAtE,OAAA6F,EAAA,OAAA7F,CAAA2F,KAAApG,KAAAe,kBACPgF,EAAAM,GAAA,KAAAN,EAAAM,GAAA,IACAd,EAAA4B,MAAAhB,EAAAX,IAGAD,EAAAF,QACArF,KAAAsH,oBAAAvC,GAEA,QAAAwC,EAAAhC,EAAAF,OAAA,EAA2CkC,GAAA,IAAQA,EACnDvH,KAAAwH,cAAAC,MAAAzH,KAAAuF,EAAAgC,IAGA,QAAAvH,KAAAc,eAQA,SAAAZ,EAAA6E,GACA/E,KAAAiB,wBAAA,EACAjB,KAAAsH,oBAAAvC,GAEA,MAAAS,EAAAT,EAAAmC,WACA,QAAAjB,EAAA,EAAAC,EAAAlG,KAAA0B,cAAA2D,OAAiDY,EAAAC,IAAQD,EAAA,CACzD,MAAAyB,EAAA1H,KAAA0B,cAAAuE,GACA0B,EAAAD,EAAA,GACAlB,EAAAmB,EAAAnB,MACAG,EAAAgB,EAAAhB,SACA,IAAAiB,EACA,MAAAxB,EAAAuB,EAAAvB,QACAtB,EAAA4C,EAAA,GAEA,KAAAlC,EAAAH,OAAAsB,EAAAkB,aACArC,EAAA2B,KAAAf,EAAAtB,GAAAU,EAAAH,SAGA,OAAAsB,EAAAC,WACA,KAAAC,EAAA,EAAAiB,MACAF,EAAApC,EACAY,EAAA,GAAAA,EAAA,GAAAZ,EACA,MACA,KAAAqB,EAAA,EAAAkB,aACAH,EAAAjB,EAAAjB,kBACAiC,EAAA7C,OAAAU,EACAY,EAAA,GAAAA,EAAA,GAAAZ,EACA,MACA,KAAAqB,EAAA,EAAAO,aACAQ,EAAAjB,EAAAjB,kBACAiC,EAAA7C,SAAAU,EACAY,EAAAtB,GAAAU,EACA,MACA,KAAAqB,EAAA,EAAAQ,kBAKA,KAAAR,EAAA,EAAAmB,SACAJ,EAAAjB,EAAAjB,kBACAc,EAAA,IAAAmB,EAAA7C,SAAAU,EACAY,EAAAtB,GAAAU,EACA,MACA,KAAAqB,EAAA,EAAAoB,eACAL,EAAAjB,EAAAjB,kBACAc,EAAA,IAAAA,EAAA,IAAAmB,EAAA7C,SAAAU,EACAY,EAAAtB,GAAAU,EACA,MACA,KAAAqB,EAAA,EAAAC,OACAV,EAAA,GAAAA,EAAA,GAAAZ,EACAmC,EAAA7C,QAAAnF,EAAAuI,oCACAlI,KAAAyB,kBAAA,EACAkF,EAAAwB,UAAA3C,GACAxF,KAAAyB,kBAAA,IAEAzB,KAAAyB,kBAAA,EACAkF,EAAAyB,UAAA3H,OAAAyG,EAAA,SAAAzG,CAAAkG,EAAA0B,YAAA7C,IACAxF,KAAAyB,kBAAA,GAOAmG,GACA5H,KAAAsI,wBAAA3B,EAAAiB,GAGA5H,KAAAuI,6BAAA/C,GASA,SAAApF,EAAA2E,GACA,IAAA4C,EACAhB,EACA,QAAAV,EAAAjG,KAAA0B,cAAA2D,OAAA,EAA6CY,GAAA,IAAQA,EAGrD,IADAU,GADAgB,EAAA3H,KAAA0B,cAAAuE,GAAA,IACAU,UACAC,YAAAC,EAAA,EAAAC,OAAA,CAEA,MAAAc,EAAAjB,EAAA0B,YACAG,EAAAb,EAAAc,gBAAA,GACAC,EAAAf,EAAAc,gBAAA,GACAD,EAAApC,QAAA,GAAAoC,EAAApC,QAAA,GAAAwB,EACAc,EAAAtC,QAAA,GAAAsC,EAAAtC,QAAA,GAAAwB,EACA5H,KAAAmB,OAAAwH,OAAAlI,OAAAmF,EAAA,6BAAAnF,CAAAmH,GAAAY,GACAxI,KAAAmB,OAAAwH,OAAAhC,EAAAiC,YAAAF,QAEA1I,KAAAmB,OAAAwH,OAAAlI,OAAAmF,EAAA,eAAAnF,CAAAkH,EAAAvB,SACAuB,GAQA,OALA3H,KAAAkB,YACAlB,KAAA6I,cAAA,IAAAlJ,EAAAmJ,MACAtJ,EAAAE,UAAAM,KAAAiE,UAAAc,IACA/E,KAAAkB,WAAA,IAEA,EAWA,SAAAf,EAAAK,GACA,KAAAA,aAAAuI,EAAA,SACA,SAIA,IAAAC,EAkBA,OApBAhJ,KAAA0E,kBAAAlE,EAGAA,EAAA0E,IAAA+D,UAAAC,kBACA1I,EAAA2I,MAAAC,EAAA,EAAAC,aACArJ,KAAAsJ,wBACAtJ,KAAAuJ,mBAAA/I,GAEAR,KAAAc,gBAAAd,KAAAU,iBAAAF,KAIAwI,IAHAxI,EAAA2I,MAAAC,EAAA,EAAAI,cAAAxJ,KAAAiB,yBACAjB,KAAAyJ,eAMAjJ,EAAA2I,MAAAC,EAAA,EAAAI,cACAxJ,KAAAiB,wBAAA,GAGAnB,EAAA,YAAAC,KAAAC,KAAAQ,KAAAwI,EA4FA,SAAAU,EAAAC,EAAAhC,GACA,MAAAhB,EAAAgB,EAAAhB,SAEA,GAAAA,EAAAC,YAAAC,EAAA,EAAAC,OAAA,CACA,MAAA8C,EAAqD,EAErD,GAAAjC,EAAA7C,QAAAnF,EAAAoH,0CAAA,CACA,MAAA8C,EACApJ,OAAAyG,EAAA,gBAAAzG,CAAAmJ,EAAAvB,YAAAsB,GACAG,EACAC,KAAAC,KAAAH,GAAAD,EAAAK,YACA,OAAAH,KAGA,OAAArJ,OAAAyG,EAAA,yBAAAzG,CAAAkJ,EAAAhC,EAAAvB,SAYA,SAAAa,EAAA0C,EAAAhC,GACA,MAAAhB,EAAAgB,EAAAhB,SAEA,OAAAA,EAAAC,YAAAC,EAAA,EAAAC,QACAa,EAAA7C,QAAAnF,EAAAoH,0CACAJ,EAAAuD,gBAAAP,GAEAlJ,OAAAyG,EAAA,iBAAAzG,CAAAkJ,EAAAhC,EAAAvB,SA1sBA3F,OAAA6F,EAAA,SAAA7F,CAAAd,EAAAG,EAAA,SAOAH,EAAAuI,mCAAA,EAMAvI,EAAAoH,0CAAA,EAOApH,EAAAwK,UAAAhG,YAAA,SAAAoC,GACA,MAAAI,EAAAJ,EAAAd,cACAkB,KAAAC,YAAA5G,KAAAqC,kBACArC,KAAAqC,iBAAAsE,EAAAC,WAAA7G,KAAAC,KAAAuG,EAAAI,GAEA,MAAAzB,EAAAlF,KAAAoK,SACAlF,KAAAmF,cAAArK,KAAAsK,aACAtK,KAAAgF,sBAAAhF,KAAAgB,WAAAkE,GAEAzE,OAAAiD,EAAA,OAAAjD,CAAA8F,EAAAgE,EAAA,EAAAC,OACAxK,KAAAyK,qBAAAzK,OAQAL,EAAAwK,UAAA7C,oBAAA,SAAAvC,GACA/E,KAAAkB,YACAlB,KAAAkB,WAAA,EACAlB,KAAA6I,cAAA,IAAAlJ,EAAAmJ,MACAtJ,EAAAC,YAAAO,KAAAiE,UAAAc,MASApF,EAAAwK,UAAAO,eAAA,SAAAnE,GACAvG,KAAA2K,0BAAApE,GAGAvG,KAAAc,gBAAA,IAAAd,KAAAiE,UAAA2G,cACA5K,KAAA2B,SAAAkJ,YAAAC,cAAA9K,KAAAc,gBACAd,KAAAc,eAAA,MAEAL,OAAAiD,EAAA,SAAAjD,CAAA8F,EAAAgE,EAAA,EAAAC,OACAxK,KAAAyK,qBAAAzK,OAQAL,EAAAwK,UAAAQ,0BAAA,SAAApE,GACA,MAAAwE,EAAA/K,KAAAmB,OACoD6J,KACpDD,EAAA7G,QAIA,SAAA+G,GACA1E,IAAA0E,EAAA1E,SACAyE,EAAA7D,KAAA8D,KAGA,QAAAhF,EAAA+E,EAAA3F,OAAA,EAAwCY,GAAA,IAAQA,EAChD8E,EAAAG,OAAAF,EAAA/E,KAQAtG,EAAAwK,UAAAgB,UAAA,SAAAC,GACApL,KAAAc,iBAAAsK,IACApL,KAAA2B,SAAAkJ,YAAAC,cAAA9K,KAAAc,gBACAd,KAAAc,eAAA,MAEAhB,EAAA,QAAAqK,UAAAgB,UAAApL,KAAAC,KAAAoL,IAOAzL,EAAAwK,UAAAkB,OAAA,SAAAnG,GACAlF,KAAA2B,SAAA0J,OAAAnG,GACApF,EAAA,QAAAqK,UAAAkB,OAAAtL,KAAAC,KAAAkF,IAQAvF,EAAAwK,UAAAtG,iBAAA,SAAAyH,GACAA,EAAA/E,SACAvG,KAAAiE,UAAAkD,KAAAmE,EAAA/E,UASA5G,EAAAwK,UAAApG,oBAAA,SAAAuH,GACAA,EAAA/E,SACAvG,KAAAiE,UAAAiH,OAAAI,EAAA/E,UASA5G,EAAAwK,UAAA5F,kBAAA,SAAAQ,GACA/E,KAAAmE,YAAyCY,EAAA,UAQzCpF,EAAAwK,UAAAM,qBAAA,SAAA1F,GACA,IAAA/E,KAAAyB,iBAAA,CACA,MAAA8E,EAA0CxB,EAAA,OAC1C/E,KAAA0K,eAAAnE,GACAvG,KAAAmE,YAAAoC,KASA5G,EAAAwK,UAAA1F,qBAAA,SAAAM,GACA,MAAAwB,EAAwCxB,EAAA,QACxC/E,KAAA0K,eAAAnE,IASA5G,EAAAwK,UAAA5H,oBAAA,SAAAgE,EAAAI,GACA,MAAAiB,EAAAjB,EAAAjB,iBACAiC,GACApB,UACAI,WACAP,SAAAwB,MAEA5H,KAAAmB,OAAAoK,OAAA5E,EAAAiC,YAAAjB,IASAhI,EAAAwK,UAAArH,yBAAA,SAAAyD,EAAAI,GACA,MAAA6E,EAAA7E,EAAAjB,iBACA,IAAAkC,EAAA3B,EAAAC,EAAAyB,EACA,IAAA1B,EAAA,EAAAC,EAAAsF,EAAAnG,OAAiCY,EAAAC,IAAQD,EAEzC0B,GACApB,UACAI,WACAH,OAAAP,GACAnB,MAAAmB,EACAG,SANAwB,EAAA4D,EAAAvF,GAMA2B,IAEA5H,KAAAmB,OAAAoK,OAAA5E,EAAAiC,YAAAjB,IAUAhI,EAAAwK,UAAA1H,yBAAA,SAAA8D,EAAAI,GACA,MAAAiB,EAAAjB,EAAAjB,iBACA,IAAAO,EAAAC,EAAAE,EAAAuB,EACA,IAAA1B,EAAA,EAAAC,EAAA0B,EAAAvC,OAAA,EAA0CY,EAAAC,IAAQD,EAElD0B,GACApB,UACAI,WACA7B,MAAAmB,EACAG,QALAA,EAAAwB,EAAA6D,MAAAxF,IAAA,IAOAjG,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA2F,GAAAuB,IAUAhI,EAAAwK,UAAAnH,8BAAA,SAAAuD,EAAAI,GACA,MAAA+E,EAAA/E,EAAAjB,iBACA,IAAAkC,EAAA3B,EAAAC,EAAAqB,EAAAoE,EAAAvF,EAAAuB,EACA,IAAAJ,EAAA,EAAAoE,EAAAD,EAAArG,OAAgCkC,EAAAoE,IAAQpE,EAExC,IAAAtB,EAAA,EAAAC,GADA0B,EAAA8D,EAAAnE,IACAlC,OAAA,EAA4CY,EAAAC,IAAQD,EAEpD0B,GACApB,UACAI,WACAH,OAAAe,GACAzC,MAAAmB,EACAG,QANAA,EAAAwB,EAAA6D,MAAAxF,IAAA,IAQAjG,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA2F,GAAAuB,IAWAhI,EAAAwK,UAAAvH,sBAAA,SAAA2D,EAAAI,GACA,MAAAiF,EAAAjF,EAAAjB,iBACA,IAAAkC,EAAA3B,EAAAC,EAAAqB,EAAAoE,EAAAvF,EAAAuB,EACA,IAAAJ,EAAA,EAAAoE,EAAAC,EAAAvG,OAAgCkC,EAAAoE,IAAQpE,EAExC,IAAAtB,EAAA,EAAAC,GADA0B,EAAAgE,EAAArE,IACAlC,OAAA,EAA4CY,EAAAC,IAAQD,EAEpD0B,GACApB,UACAI,WACAH,OAAAe,GACAzC,MAAAmB,EACAG,QANAA,EAAAwB,EAAA6D,MAAAxF,IAAA,IAQAjG,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA2F,GAAAuB,IAWAhI,EAAAwK,UAAAjH,2BAAA,SAAAqD,EAAAI,GACA,MAAAkF,EAAAlF,EAAAjB,iBACA,IAAAkC,EAAA3B,EAAAC,EAAAqB,EAAAoE,EAAAG,EAAAC,EAAAH,EAAAxF,EAAAuB,EACA,IAAAmE,EAAA,EAAAC,EAAAF,EAAAxG,OAAmCyG,EAAAC,IAAQD,EAE3C,IAAAvE,EAAA,EAAAoE,GADAC,EAAAC,EAAAC,IACAzG,OAAkCkC,EAAAoE,IAAQpE,EAE1C,IAAAtB,EAAA,EAAAC,GADA0B,EAAAgE,EAAArE,IACAlC,OAAA,EAA8CY,EAAAC,IAAQD,EAEtD0B,GACApB,UACAI,WACAH,OAAAe,EAAAuE,GACAhH,MAAAmB,EACAG,QANAA,EAAAwB,EAAA6D,MAAAxF,IAAA,IAQAjG,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA2F,GAAAuB,IAkBAhI,EAAAwK,UAAA/G,qBAAA,SAAAmD,EAAAI,GACA,MAAAiB,EAAAjB,EAAA0B,YACAG,GACAjC,UACAI,WACA7B,MAAAnF,EAAAuI,mCACA9B,SAAAwB,MAEAc,GACAnC,UACAI,WACA7B,MAAAnF,EAAAoH,0CACAX,SAAAwB,MAEAa,GAAAD,EAAAE,GACAF,EAAAC,gBAAAC,EAAAD,kBACAzI,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,6BAAAnF,CAAAmH,GAAAY,GACAxI,KAAAmB,OAAAoK,OAAA5E,EAAAiC,YAAAF,IASA/I,EAAAwK,UAAA7G,iCAAA,SAAAiD,EAAAI,GACA,MAAAqF,EAAArF,EAAAsF,qBACA,QAAAhG,EAAA,EAAiBA,EAAA+F,EAAA3G,SAAuBY,EACxCjG,KAAAqC,iBAAA2J,EAAA/F,GAAAW,WAAA7G,KAAAC,KAAAuG,EAAAyF,EAAA/F,KAUAtG,EAAAwK,UAAA5B,6BAAA,SAAAX,GACA,IAAAtC,EAAAtF,KAAAc,eACA,GAAAwE,EAIG,CAC2CA,EAAAG,cAC9CyG,eAAAtE,QALAtC,EAAA,IAAA6G,EAAA,YAAA7J,EAAA,QAAAsF,IACA5H,KAAAc,eAAAwE,EACAtF,KAAA2B,SAAAkJ,YAAAuB,WAAA9G,GAKA,OAAAA,GA+OA3F,EAAAwK,UAAAZ,mBAAA,SAAAxE,GACA/E,KAAAgB,WAAA+D,EAAAE,MACAjF,KAAAgF,sBAAAD,EAAAE,MAAAF,EAAAG,MASAvF,EAAAwK,UAAAnF,sBAAA,SAAAC,EAAAC,GACA,MAAAC,EAAAD,EAAAE,uBAAAH,GACAoH,EAAA,SAAAzH,EAAAC,GACA,OAAA6E,EAAAvE,EAAAP,GACA8E,EAAAvE,EAAAN,IAGAyH,EAAA7L,OAAAmF,EAAA,OAAAnF,QAAAmF,EAAA,6BAAAnF,CAAA0E,GACAD,EAAA+D,UAAAsD,gBAAAvM,KAAAqB,iBAGAmL,EADAxM,KAAAmB,OACA2E,YAAAwG,GACA,GAAAE,EAAAnH,OAAA,GACAmH,EAAAxG,KAAAqG,GACA,MAAApB,EAAAuB,EAAA,GACAC,EAAAxB,EAAA7E,QACA,IAAAZ,EAAAyB,EAAA9B,EAAA8F,GACA,MAAAyB,EAAAxH,EAAAyH,uBAAAnH,GACA,IAAAoH,EAAAnM,OAAAyG,EAAA,SAAAzG,CAAAwE,EAAAyH,GACA,GAAAE,GAAA5M,KAAAqB,gBAAA,CACA,MAAAwL,KAEA,GAAA5B,EAAAtE,SAAAC,YAAAC,EAAA,EAAAC,QACAmE,EAAAnG,QAAAnF,EAAAoH,0CAEA/G,KAAAwB,kBAAA,EACAxB,KAAAuI,6BAAA/C,OACO,CACP,MAAAsH,EAAA5H,EAAAyH,uBAAAF,EAAA,IACAM,EAAA7H,EAAAyH,uBAAAF,EAAA,IACAO,EAAAvM,OAAAyG,EAAA,gBAAAzG,CAAAiM,EAAAI,GACAG,EAAAxM,OAAAyG,EAAA,gBAAAzG,CAAAiM,EAAAK,GAOA,IAAA3G,EANAwG,EAAA7C,KAAAC,KAAAD,KAAAmD,IAAAF,EAAAC,IACAjN,KAAAwB,iBAAAoL,GAAA5M,KAAAqB,gBACArB,KAAAwB,mBACAgE,EAAAwH,EAAAC,EAAAR,EAAA,GAAAA,EAAA,IAEAzM,KAAAuI,6BAAA/C,GAEA,QAAAS,EAAA,EAAAC,EAAAsG,EAAAnH,OAA0CY,EAAAC,IAC1CE,EAAAoG,EAAAvG,GAAAG,QACA3F,OAAAyG,EAAA,OAAAzG,CAAAgM,EAAA,GAAArG,EAAA,KACA3F,OAAAyG,EAAA,OAAAzG,CAAAgM,EAAA,GAAArG,EAAA,KACA3F,OAAAyG,EAAA,OAAAzG,CAAAgM,EAAA,GAAArG,EAAA,KACA3F,OAAAyG,EAAA,OAAAzG,CAAAgM,EAAA,GAAArG,EAAA,OALkDH,EAMlD4G,EAAApM,OAAA6F,EAAA,OAAA7F,CAAA2F,KAAA,EASA,OAFAyG,EAAApM,OAAA6F,EAAA,OAAA7F,CAAAgM,KAAA,OACAzM,KAAAe,gBAAA8L,IAIA7M,KAAAc,iBACAd,KAAA2B,SAAAkJ,YAAAC,cAAA9K,KAAAc,gBACAd,KAAAc,eAAA,OAwDAnB,EAAAwK,UAAA3C,cAAA,SAAAG,EAAAnC,GACA,MAAAY,EAAAuB,EAAAvB,QACAG,EAAAoB,EAAApB,QACAI,EAAAgB,EAAAhB,SACAH,EAAAmB,EAAAnB,MACA1B,EAAkC6C,EAAA,MAClC,IAAAC,EAEA,KAAApC,EAAAH,OAAAsB,EAAAkB,aACArC,EAAA2B,KAAA,GAGA,OAAAR,EAAAC,WACA,KAAAC,EAAA,EAAAQ,kBAIA,KAAAR,EAAA,EAAAmB,SACAJ,EAAAjB,EAAAjB,kBACAc,EAAA,IAAA2G,OAAArI,EAAA,IAAAU,GACA,MACA,KAAAqB,EAAA,EAAAoB,eACAL,EAAAjB,EAAAjB,kBACAc,EAAA,IAAAA,EAAA,IAAA2G,OAAArI,EAAA,IAAAU,GACA,MACA,KAAAqB,EAAA,EAAAO,aACAQ,EAAAjB,EAAAjB,kBACAyH,OAAArI,EAAA,IAAAU,GACA,MACA,QACA,OAGAxF,KAAAsI,wBAAA3B,EAAAiB,GACA,MAAAwF,EAAApN,KAAAmB,OACAiM,EAAAlC,OAAAvD,GACA3H,KAAAqN,sBAAA1G,EAAA7B,EAAA0B,EAAA,GACA,MAAA8G,GACAlH,WAAA,GAAAZ,GACAe,UACAI,WACAH,QACA1B,SAEAsI,EAAA7B,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA6M,EAAAlH,SACAkH,GACAtN,KAAA0B,cAAAyF,MAAAmG,EAAA,IAEA,MAAAC,GACAnH,SAAAZ,EAAAY,EAAA,IACAG,UACAI,WACAH,QACA1B,QAAA,GAEAsI,EAAA7B,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA8M,EAAAnH,SAAAmH,GACAvN,KAAA0B,cAAAyF,MAAAoG,EAAA,IACAvN,KAAAiB,wBAAA,GAQAtB,EAAAwK,UAAAV,YAAA,WACA,GAAAzJ,KAAA0E,mBAAA1E,KAAA0E,kBAAAyE,MAAAC,EAAA,EAAAoE,YAAA,CACA,MAAAzI,EAAA/E,KAAA0E,kBAKA,OAJA1E,KAAAsH,oBAAAvC,GACA/E,KAAAyN,gBACAzN,KAAA6I,cAAA,IAAAlJ,EAAAmJ,MAAAtJ,EAAAE,UAAAM,KAAAiE,UAAAc,IACA/E,KAAAkB,WAAA,GACA,EAEA,UAQAvB,EAAAwK,UAAAsD,cAAA,WACA,MAAAC,EAAA1N,KAAA0B,cACAiM,KACA,IACAC,EAAAhG,EAAAF,EAAAf,EAAAV,EAAAnB,EAAA+I,EACAC,EAAAC,EAAApG,EAAAtB,EAFA2H,GAAA,EAGA,IAAA/H,EAAAyH,EAAArI,OAAA,EAAmCY,GAAA,IAAQA,EAE3C0B,GADAD,EAAAgG,EAAAzH,IACA,GACAI,EAAA5F,OAAA6F,EAAA,OAAA7F,CAAAkH,EAAApB,SACAoB,EAAAnB,QAEAH,GAAA,IAAAsB,EAAAnB,MAAAC,KAAA,MAEAJ,KAAAsH,IACAA,EAAAtH,OAEA,IAAAqB,EAAA,IACAiG,EAAAtH,GAAA0H,MAAApG,EACAgG,EAAAtH,GAAAvB,MAAA6C,EAAA7C,OACK,GAAA4C,EAAA,KACLiG,EAAAtH,GAAAwH,KAAAlG,EACAgG,EAAAtH,GAAAvB,MAAA6C,EAAA7C,MAAA,GAIA,IAAAuB,KAAAsH,EAAA,CAiBA,OAhBAI,EAAAJ,EAAAtH,GAAA0H,MACAF,EAAAF,EAAAtH,GAAAwH,KAEAC,GADAhJ,EAAA6I,EAAAtH,GAAAvB,OACA,EAEA6C,OADArG,IAAAuM,EACAA,EAEAE,EAEAD,EAAA,IACAA,EAAA,GAIAF,EADAhG,GADAjB,EAAAgB,EAAAhB,UACAjB,iBAEAsI,GAAA,EACArH,EAAAC,WACA,KAAAC,EAAA,EAAAQ,kBACAO,EAAAD,EAAAnB,MAAA,IAAAnB,OAAA,IACAuC,EAAAD,EAAAnB,MAAA,IAAA2G,OAAArI,EAAA,GACAkJ,GAAA,GAEA,MACA,KAAAnH,EAAA,EAAAO,YACAQ,EAAAvC,OAAA,IACAuC,EAAAuF,OAAArI,EAAA,GACAkJ,GAAA,GAEA,MACA,KAAAnH,EAAA,EAAAoB,cACA2F,IAAAjG,EAAAnB,MAAA,IAEA,KAAAK,EAAA,EAAAmB,SACA4F,IAAAjG,EAAAnB,MAAA,KACAnB,OAAA,IACAP,GAAA8I,EAAAvI,OAAA,IACAP,EAAA,GAEA8I,EAAAT,OAAArI,EAAA,GACAkJ,GAAA,EACA,IAAAlJ,IAEA8I,EAAAK,MACAL,EAAAzG,KAAAyG,EAAA,IACAE,EAAAF,EAAAvI,OAAA,IAQA,GAAA2I,EAAA,CACAhO,KAAAsI,wBAAA3B,EAAAiB,GACA,MAAAsG,KASA,QARA5M,IAAAuM,IACA7N,KAAAmB,OAAA+J,OAAA2C,GACAK,EAAA/G,KAAA0G,EAAAzH,QAAA,UAEA9E,IAAAyM,IACA/N,KAAAmB,OAAA+J,OAAA6C,GACAG,EAAA/G,KAAA4G,EAAA3H,QAAA,UAEA9E,IAAAuM,QAAAvM,IAAAyM,EAAA,CACA,MAAAT,GACA9G,MAAAmB,EAAAnB,MACAD,QAAAoB,EAAApB,QACAI,SAAAgB,EAAAhB,SACA7B,MAAAgJ,EACA1H,QAAA8H,GAEAlO,KAAAmB,OAAAoK,OAAA9K,OAAAmF,EAAA,eAAAnF,CAAA6M,EAAAlH,SACAkH,GAEAtN,KAAAqN,sBAAA1G,EAAA7B,EAAA6C,EAAAnB,OAAA,GACAxG,KAAAc,iBACAd,KAAA2B,SAAAkJ,YAAAC,cAAA9K,KAAAc,gBACAd,KAAAc,eAAA,MAEA4M,EAAArI,OAAA,GAIA,OAAA2I,GASArO,EAAAwK,UAAA7B,wBAAA,SAAA3B,EAAAiB,GACA5H,KAAAyB,kBAAA,EACAkF,EAAAuF,eAAAtE,GACA5H,KAAAyB,kBAAA,GAWA9B,EAAAwK,UAAAkD,sBAAA,SACA1G,EAAA7B,EAAA0B,EAAA2H,GACAnO,KAAAmB,OAAAiN,gBAAAzH,EAAAiC,YAAA,SAAAzC,GACAA,EAAAQ,oBACArF,IAAAkF,QAAAlF,IAAA6E,EAAAK,OACA/F,OAAA4N,EAAA,OAAA5N,CAAA0F,EAAAK,WACAL,EAAArB,UACAqB,EAAArB,OAAAqJ,MASAxO,EAAAuC,wBAAA,WACA,MAAAD,EAAAqM,EAAA,QAAAC,uBACA,gBAAAhI,EAAAiI,GACA,OAAAvM,EAAA4E,EAAA,EAAAiB,SAkBAnI,EAAAmJ,MAAA,SAAAK,EAAAtJ,EAAA4O,GAEA3F,EAAA,QAAA/I,KAAAC,KAAAmJ,GAOAnJ,KAAAH,WAOAG,KAAAQ,gBAAAiO,GAGAhO,OAAA6F,EAAA,SAAA7F,CAAAd,EAAAmJ,QAAA,SAEA4F,EAAA,sGCvsCAC,EAAAC,EAAA,GAeA,MAAAC,EAAA,SAAAC,GAEA,MAAAlP,EAAAkP,MAEA,IAAAC,EAEAA,OADAzN,IAAA1B,EAAAmP,aACAnP,EAAAmP,cAEAF,EAAAG,aAGA,MAAAC,OAAA3N,IAAA1B,EAAAqP,YACArP,EAAAqP,YAAA,YAEAC,OAAA5N,IAAA1B,EAAAsP,IACAtP,EAAAsP,IAAA,uDAEAP,EAAA,EAAA5O,KAAAC,MACA+O,eACAI,UAAAvP,EAAAuP,UACAF,cACAG,YAAA9N,IAAA1B,EAAAwP,QAAAxP,EAAAwP,OACAC,aAAA/N,IAAA1B,EAAAyP,QAAAzP,EAAAyP,QAAA,GACAC,2BAAA1P,EAAA0P,2BACAC,iBAAA3P,EAAA2P,iBACAL,MACAlN,MAAApC,EAAAoC,SAKAvB,OAAA+O,EAAA,SAAA/O,CAAAoO,EAAAF,EAAA,GAUAE,EAAAG,YAAA,2FAGAN,EAAA,wICtDAE,EAAA,KACAA,EAAA,GACA,QAAAA,EAAA,UAEAA,EAAA,UACAA,EAAA,SACAA,EAAA,SACAA,EAAA,SACAA,EAAA,SACAA,EAAA,QACAA,EAAA,SACAA,EAAA,UACAA,EAAA,SACAA,EAAA,SACAA,EAAA,SACAA,EAAA,wDAjBA,IAAMa,KAqBAC,EAASC,QAAQD,OAAO,OAC5BE,EAAAC,QAAcC,OAQhBL,EAAQM,eAAiB,WAMvB/P,KAAKkF,IAAM,IAAA8K,EAAAH,SACTI,QACE,IAAAC,EAAAL,SACEhO,OAAQ,IAAAsO,EAAAN,WAGZO,KAAM,IAAAC,EAAAR,SACJS,SAAU,SAAU,SACpBC,KAAM,MAIV,IAAMrL,EAAMlF,KAAKkF,IAEXsL,EAAS,IAAAC,EAAAZ,UAAmB,SAAU,SAAU,OAMtD7P,KAAKH,SAAW,IAAA6Q,EAAAb,QAEhB,IAAMc,EAAgB,IAAAC,EAAAf,SACpBlJ,SAAUkK,EAAAhB,QAAciB,WAAWN,GACnCO,MAAO,UACPC,MAAO,WACPC,QAAS,MACTC,OAAQ,MAGVP,EAAcQ,IAAIC,EAAAvB,QAA4BwB,WAAW,GACzDrR,KAAKH,SAASsH,KAAKwJ,GAEnB,IAAMW,EAAe,IAAAC,EAAA1B,SACnBhQ,SAAUG,KAAKH,WAEG,IAAA2R,EAAA3B,SAClBhO,OAAQyP,IAKEjG,OAAOnG,GAMnBlF,KAAKyR,YAAc,IAAAC,EAAA7B,SAEfhQ,SAAUG,KAAKH,WAGnB,IAAM4R,EAAczR,KAAKyR,YACzBA,EAAYtG,WAAU,GACtBjG,EAAIyM,eAAeF,IAKrB/B,EAAOkC,WAAW,iBAAkBnC,EAAQM,0BAG7BN,yGCnGf,QAAAb,EAAA,QACAA,EAAA,UACAA,EAAA,MACYiD,IAAZjD,EAAA,QACAA,EAAA,SACAA,EAAA,MACYkD,IAAZlD,EAAA,KACYmD,IAAZnD,EAAA,IACYoD,IAAZpD,EAAA,QACAA,EAAA,UACAA,EAAA,SACAA,EAAA,SACAA,EAAA,SACAA,EAAA,UACAA,EAAA,SACAA,EAAA,SACAA,EAAA,SACAA,EAAA,UACAA,EAAA,iNAaA,IAAMa,EAAU,SAAVA,EAAmB7P,GAEvBqS,EAAApC,QAAYqC,OAAOtS,EAAQC,UAE3BsS,EAAAtC,QAAqB9P,KAAKC,MACxBC,gBAAiBwP,EAAQ2C,iBACzBlS,gBAAiBuP,EAAQ4C,iBACzBlS,YAAasP,EAAQtP,YACrBC,cAAeqP,EAAQ6C,iBAQzBtS,KAAKc,eAAiB,KAMtBd,KAAKgB,YAAc,EAAG,GAMtBhB,KAAKkB,WAAY,EAOjBlB,KAAKmB,OAAS,IAAAoR,EAAA1C,QAMd7P,KAAKqB,qBAA6CC,IAA3B1B,EAAQ2B,eAC7B3B,EAAQ2B,eAAiB,GAM3BvB,KAAKwB,kBAAmB,EAQxBxB,KAAKyB,kBAAmB,EAMxBzB,KAAK0B,cAAgB,KAOrB1B,KAAK2B,SAAW,IAAA6P,EAAA3B,SACdhO,OAAQ,IAAA0P,EAAA1B,SACN9N,iBAAiB,EACjBC,QAASpC,EAAQoC,QAEnBC,MAAOrC,EAAQqC,MAAQrC,EAAQqC,MAC7BwN,EAAQvN,0BACVC,sBAAsB,EACtBC,wBAAwB,IAO1BpC,KAAKiE,UAAYrE,EAAQC,SAEzBG,KAAKiE,UAAUC,QAAQlE,KAAKmE,YAAanE,MACzC+R,EAASS,OAAOxS,KAAKiE,UAAW,MAAOjE,KAAKuE,kBAAmBvE,MAC/D+R,EAASS,OAAOxS,KAAKiE,UAAW,SAAUjE,KAAKyE,qBAAsBzE,OAIvE6R,EAAOY,SAAShD,EAAhB0C,EAAAtC,SAOAJ,EAAQtF,UAAUhG,YAAc,SAASoC,GACvC,GAAwC,YAApCA,EAAQd,cAAcmB,WACpBL,EAAQmM,IAAItB,EAAAvB,QAA4BwB,WAAY,CACxD,IAAM1K,EAA0CJ,EAAQd,cACxDzF,KAAKoD,qBAAqBmD,EAASI,GAEnC,IAAMzB,EAAMlF,KAAKoK,SACblF,GACFlF,KAAKgF,sBAAsBhF,KAAKgB,WAAYkE,KAUlDuK,EAAQtF,UAAU7C,oBAAsB,SAASvC,GAC1C/E,KAAKkB,YACRlB,KAAKkB,WAAY,EACjBlB,KAAK6I,cAAc,IAAI8J,EAAA9C,QAAoB/G,MACM,cAAgB9I,KAAKiE,UAAWc,MASrF0K,EAAQtF,UAAUO,eAAiB,SAASnE,GAC1CvG,KAAK2K,0BAA0BpE,GAG3BvG,KAAKc,gBAAiD,IAA/Bd,KAAKiE,UAAU2G,cACxC5K,KAAK2B,SAASkJ,YAAYC,cAAc9K,KAAKc,gBAC7Cd,KAAKc,eAAiB,OAS1B2O,EAAQtF,UAAUQ,0BAA4B,SAASpE,GACrD,IAAMwE,EAAQ/K,KAAKmB,OACmC6J,KACtDD,EAAM7G,QAIJ,SAAC+G,GACK1E,IAAY0E,EAAK1E,SACnByE,EAAc7D,KAAK8D,KAGzB,IAAK,IAAIhF,EAAI+E,EAAc3F,OAAS,EAAGY,GAAK,IAAKA,EAC/C8E,EAAMG,OAAOF,EAAc/E,KAQ/BwJ,EAAQtF,UAAUkB,OAAS,SAASnG,GAClClF,KAAK2B,SAAS0J,OAAOnG,GACrBiN,EAAAtC,QAAqB1F,UAAUkB,OAAOtL,KAAKC,KAAMkF,IAQnDuK,EAAQtF,UAAU5F,kBAAoB,SAASQ,GAC7C,IAAMwB,EAAUxB,EAAI6N,QACpBX,EAAApC,QAAYgD,iBAAiBtM,EAA7BqK,EAAAf,QACE,mCACF7P,KAAKmE,YAAYoC,IAQnBkJ,EAAQtF,UAAU1F,qBAAuB,SAASM,GAChD,IAAMwB,EAAqCxB,EAAI6N,QAC/C5S,KAAK0K,eAAenE,IAStBkJ,EAAQtF,UAAU/G,qBAAuB,SAASmD,EAASI,GACzD,IAC2BgF,EADrBC,EAAQjF,EAASjB,iBACnBkC,SAAa3B,SAAGC,SAAIqB,SAAOnB,SAASuB,SACxC,IAAKJ,EAAI,EAAGoE,EAAKC,EAAMvG,OAAQkC,EAAIoE,IAAMpE,EAEvC,IAAKtB,EAAI,EAAGC,GADZ0B,EAAcgE,EAAMrE,IACSlC,OAAS,EAAGY,EAAIC,IAAMD,EAEjD0B,GACEpB,QAASA,EACTI,SAAUA,EACVH,OAAQe,GACRzC,MAAOmB,EACPG,QANFA,EAAUwB,EAAY6D,MAAMxF,EAAGA,EAAI,IAQnCjG,KAAKmB,OAAOoK,OAAOyG,EAASc,eAAe1M,GAAUuB,IAW3D8H,EAAQtF,UAAU5B,6BAA+B,SAASX,GACxD,IAAItC,EAAgBtF,KAAKc,eACpBwE,EAK4CA,EAAcG,cACpDyG,eAAetE,IALxBtC,EAAgB,IAAAsL,EAAAf,QAAc,IAAAkD,EAAAlD,QAAgBjI,IAC9C5H,KAAKc,eAAiBwE,EACtBtF,KAAK2B,SAASkJ,YAAYuB,WAAW9G,IAKvC,OAAOA,GAUTmK,EAAQuD,gBAAkB,SAASpO,EAAGC,GACpC,OAAOD,EAAEE,MAAQD,EAAEC,OAUrB2K,EAAQ2C,iBAAmB,SAASrN,GAClC/E,KAAKgF,sBAAsBD,EAAIE,MAAOF,EAAIG,KAC1ClF,KAAK0B,iBACL1B,KAAKkB,WAAY,EACjB,IAAMoE,EAAgBtF,KAAKc,eAC3B,GAAIwE,EAAe,CACjB,IACME,EADyCF,EAAcG,cACrCC,iBAClBC,EAAeqM,EAASc,gBAAgBtN,IACxCK,EAAqB7F,KAAKmB,OAAO2E,YAAYH,GAC7CI,KACNF,EAAmBG,KAAKyJ,EAAQuD,iBAChC,IAAK,IAAI/M,EAAI,EAAGC,EAAKL,EAAmBR,OAAQY,EAAIC,IAAMD,EAAG,CAC3D,IAAME,EAAmBN,EAAmBI,GACtCG,EAAUD,EAAiBC,QAC7BC,EAAMwL,EAAOoB,OAAO9M,EAAiBI,SACnCC,EAAQL,EAAiBK,MAC3BA,IACFH,OAAWG,EAAMC,KAAK,MAEnBV,EAAkBM,KACrBN,EAAkBM,GAAO,IAAIK,MAAM,IAEjCoL,EAAaoB,OAAO9M,EAAQ,GAAIZ,KAC/BO,EAAkBM,GAAK,IAC1BrG,KAAK0B,cAAcyF,MAAMhB,EAAkB,IAC3CJ,EAAkBM,GAAK,GAAKF,GACnB2L,EAAaoB,OAAO9M,EAAQ,GAAIZ,KACtCO,EAAkBM,GAAK,KAC1BrG,KAAK0B,cAAcyF,MAAMhB,EAAkB,IAC3CJ,EAAkBM,GAAK,GAAKF,IAIlC,QAASnG,KAAKc,gBAShB2O,EAAQ4C,iBAAmB,SAAStN,GAClC/E,KAAKsH,oBAAoBvC,GACzB,IAAMS,EAAST,EAAImC,WACbP,EAC6B3G,KAAK0B,cAAc,GAAG,GAAGiF,SACtD2J,EAAS0B,EAAS3J,UAAU1B,EAASiC,aAErCuK,EAAO,IAAAC,EAAAvD,SAAsBS,EAAQ9K,IAMrCgL,EAAS,IAAAC,EAAAZ,QAAiBS,EAAQ6C,EAAKvI,aACvChD,EAAciJ,EAAAhB,QAAciB,WAAWN,EAAQ,IAAI9K,iBACzD1F,KAAKsI,wBAAwB3B,EAAUiB,GAGvC,IAAMyL,EAASC,EAAAzD,QAA6B0D,UAAUJ,GACtDnT,KAAKiE,UAAUuP,WAAW,GAAGrC,IAAIC,EAAAvB,QAA4B4D,OAAQJ,GAErErT,KAAKuI,6BAA6B/C,IAUpCiK,EAAQ6C,eAAiB,SAASvN,GAUhC,OATA/E,KAAKmB,OAAOuS,QACZ1T,KAAKoD,qBAAqBpD,KAAK0B,cAAc,GAAG,GAAG6E,QACjDvG,KAAK0B,cAAc,GAAG,GAAGiF,UAEvB3G,KAAKkB,YACPlB,KAAK6I,cAAc,IAAI8J,EAAA9C,QAAoB/G,MACM,YAAc9I,KAAKiE,UAAWc,IAC/E/E,KAAKkB,WAAY,IAEZ,GAYTuO,EAAQtP,YAAc,SAASK,GAC7B,KAAMA,wBACJ,OAAO,EAST,OALKA,EAAgB0E,IAAI+D,UAAUC,kBACP,eAAxB1I,EAAgB2I,MAA0BnJ,KAAKsJ,wBACjDtJ,KAAKuJ,mBAAmB/I,GAGnB2R,EAAAtC,QAAqB1P,YAAYJ,KAAKC,KAAMQ,KAC/C,GAQNiP,EAAQtF,UAAUZ,mBAAqB,SAASxE,GAC9C/E,KAAKgB,WAAa+D,EAAIE,MACtBjF,KAAKgF,sBAAsBD,EAAIE,MAAOF,EAAIG,MAS5CuK,EAAQtF,UAAUnF,sBAAwB,SAASC,EAAOC,GACxD,IAAMC,EAAkBD,EAAIE,uBAAuBH,GAM7C0O,EAAYzO,EAAIE,wBACnBH,EAAM,GAAKjF,KAAKqB,gBAAiB4D,EAAM,GAAKjF,KAAKqB,kBAC9CuS,EAAa1O,EAAIE,wBACpBH,EAAM,GAAKjF,KAAKqB,gBAAiB4D,EAAM,GAAKjF,KAAKqB,kBAC9CiL,EAAM0F,EAASc,gBAAgBa,EAAWC,IAG1CpH,EADQxM,KAAKmB,OACC2E,YAAYwG,GAChC,GAAIE,EAAMnH,OAAS,EAAG,CACpBmH,EAAMxG,KAde,SAASpB,EAAGC,GACjC,OAAOiN,EAAa+B,yBAAyB1O,EAAiBP,EAAEwB,SAC5D0L,EAAa+B,yBAAyB1O,EAAiBN,EAAEuB,WAa7D,IACMqG,EADOD,EAAM,GACSpG,QACxBZ,EAAUsM,EAAagC,iBAAiB3O,EAC1CsH,GACIC,EAAcxH,EAAIyH,uBAAuBnH,GAC/C,GAAIuE,KAAKC,KAAK8H,EAAaiC,gBAAgB9O,EAAOyH,KAC9C1M,KAAKqB,gBAAiB,CACxB,IAAMyL,EAAS5H,EAAIyH,uBAAuBF,EAAe,IACnDM,EAAS7H,EAAIyH,uBAAuBF,EAAe,IACnDO,EAAe8E,EAAaiC,gBAAgBrH,EAAaI,GACzDG,EAAe6E,EAAaiC,gBAAgBrH,EAAaK,GACzDH,EAAO7C,KAAKC,KAAKD,KAAKmD,IAAIF,EAAcC,IAE9C,GADAjN,KAAKwB,iBAAmBoL,GAAQ5M,KAAKqB,gBACjCrB,KAAKwB,iBAAkB,CACzBgE,EAASwH,EAAeC,EACtBR,EAAe,GAAKA,EAAe,GACrCzM,KAAKuI,6BAA6B/C,GAClC,IAAMqH,KACNA,EAAegF,EAAOoB,OAAOxG,KAAmB,EAEhD,IADA,IAAIrG,SACKH,EAAI,EAAGC,EAAKsG,EAAMnH,OAAQY,EAAIC,IACrCE,EAAUoG,EAAMvG,GAAGG,QACd0L,EAAaoB,OAAOzG,EAAe,GAAIrG,EAAQ,KAChD0L,EAAaoB,OAAOzG,EAAe,GAAIrG,EAAQ,KAC9C0L,EAAaoB,OAAOzG,EAAe,GAAIrG,EAAQ,KAChD0L,EAAaoB,OAAOzG,EAAe,GAAIrG,EAAQ,OALRH,EAMzC4G,EAAegF,EAAOoB,OAAO7M,KAAY,EAK7C,SAIFpG,KAAKc,iBACPd,KAAK2B,SAASkJ,YAAYC,cAAc9K,KAAKc,gBAC7Cd,KAAKc,eAAiB,OAU1B2O,EAAQtF,UAAU7B,wBAA0B,SAAS3B,EAAUiB,GAC7D5H,KAAKyB,kBAAmB,EACxBkF,EAASuF,eAAetE,GACxB5H,KAAKyB,kBAAmB,GAO1BgO,EAAQvN,wBAA0B,WAChC,IAAMD,EAAQ+R,EAAAnE,QAAatB,uBAC3B,OAAO,SAAShI,EAASiI,GACvB,OAAOvM,EAAA,kBAKIwN,qDClffwE,EAAArF,EAAA,IA6BA,MAAAsF,EAAA,SAAApF,GACA,MAAAlP,EAAAkP,MACAqF,OAAA7S,IAAA1B,EAAAuU,WACAvU,EAAAuU,WAAA,YAEAC,OAAA9S,IAAA1B,EAAAwU,SAAAxU,EAAAwU,SACA3T,OAAAwT,EAAA,EAAAxT,EACAmF,OAAAnF,OAAAwT,EAAA,EAAAxT,CAAA0T,GACA9E,QAAAzP,EAAAyP,QACAgF,QAAAzU,EAAAyU,QACAC,SAAA1U,EAAA0U,WAGAC,EAAA,EAAAxU,KAAAC,MACA+O,aAAAnP,EAAAmP,aACAI,UAAAvP,EAAAuP,UACAF,YAAArP,EAAAqP,YACAG,OAAAxP,EAAAwP,OACA+E,aACA7E,2BAAA1P,EAAA0P,2BACA8E,WACA7E,iBAAA3P,EAAA2P,iBACAiF,eAAA5U,EAAA4U,eACAC,gBAAA7U,EAAA6U,gBACAvF,IAAAtP,EAAAsP,IACAwF,KAAA9U,EAAA8U,KACA1S,WAAAV,IAAA1B,EAAAoC,OAAApC,EAAAoC,MACA2S,WAAA/U,EAAA+U,cAKAlU,OAAA+O,EAAA,SAAA/O,CAAAyT,EAAAK,EAAA,GACA7F,EAAA","file":"modifycircle.ad5785b27fda22138430.js","sourcesContent":["/**\n * @module ol/interaction/ModifyEventType\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  /**\n   * Triggered upon feature modification start\n   * @event ol.interaction.Modify.Event#modifystart\n   * @api\n   */\n  MODIFYSTART: 'modifystart',\n  /**\n   * Triggered upon feature modification end\n   * @event ol.interaction.Modify.Event#modifyend\n   * @api\n   */\n  MODIFYEND: 'modifyend'\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/interaction/ModifyEventType.js\n// module id = null\n// module chunks = ","/**\n * @module ol/interaction/Modify\n */\nimport {getUid, inherits} from '../index.js';\nimport Collection from '../Collection.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport Feature from '../Feature.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport MapBrowserPointerEvent from '../MapBrowserPointerEvent.js';\nimport {equals} from '../array.js';\nimport {equals as coordinatesEqual, distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, squaredDistanceToSegment, closestOnSegment} from '../coordinate.js';\nimport {listen, unlisten} from '../events.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport {always, primaryAction, altKeyOnly, singleClick} from '../events/condition.js';\nimport {boundingExtent, buffer, createOrUpdateFromCoordinate} from '../extent.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport Point from '../geom/Point.js';\nimport ModifyEventType from '../interaction/ModifyEventType.js';\nimport PointerInteraction, {handleEvent as handlePointerEvent} from '../interaction/Pointer.js';\nimport VectorLayer from '../layer/Vector.js';\nimport VectorSource from '../source/Vector.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\nimport Style from '../style/Style.js';\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.  To modify features that have\n * been added to an existing source, construct the modify interaction with the\n * `source` option.  If you want to modify features in a collection (for example,\n * the collection used by a select interaction), construct the interaction with\n * the `features` option.  The interaction must be constructed with either a\n * `source` or `features` option.\n *\n * By default, the interaction will allow deletion of vertices when the `alt`\n * key is pressed.  To configure the interaction with a different condition\n * for deletion, use the `deleteCondition` option.\n *\n * @constructor\n * @extends {ol.interaction.Pointer}\n * @param {olx.interaction.ModifyOptions} options Options.\n * @fires ol.interaction.Modify.Event\n * @api\n */\nconst Modify = function(options) {\n\n  PointerInteraction.call(this, {\n    handleDownEvent: handleDownEvent,\n    handleDragEvent: handleDragEvent,\n    handleEvent: handleEvent,\n    handleUpEvent: handleUpEvent\n  });\n\n  /**\n   * @private\n   * @type {ol.EventsConditionType}\n   */\n  this.condition_ = options.condition ? options.condition : primaryAction;\n\n\n  /**\n   * @private\n   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.\n   * @return {boolean} Combined condition result.\n   */\n  this.defaultDeleteCondition_ = function(mapBrowserEvent) {\n    return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);\n  };\n\n  /**\n   * @type {ol.EventsConditionType}\n   * @private\n   */\n  this.deleteCondition_ = options.deleteCondition ?\n    options.deleteCondition : this.defaultDeleteCondition_;\n\n  /**\n   * @type {ol.EventsConditionType}\n   * @private\n   */\n  this.insertVertexCondition_ = options.insertVertexCondition ?\n    options.insertVertexCondition : always;\n\n  /**\n   * Editing vertex.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.vertexFeature_ = null;\n\n  /**\n   * Segments intersecting {@link this.vertexFeature_} by segment uid.\n   * @type {Object.<string, boolean>}\n   * @private\n   */\n  this.vertexSegments_ = null;\n\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n  this.lastPixel_ = [0, 0];\n\n  /**\n   * Tracks if the next `singleclick` event should be ignored to prevent\n   * accidental deletion right after vertex creation.\n   * @type {boolean}\n   * @private\n   */\n  this.ignoreNextSingleClick_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.modified_ = false;\n\n  /**\n   * Segment RTree for each layer\n   * @type {ol.structs.RBush.<ol.ModifySegmentDataType>}\n   * @private\n   */\n  this.rBush_ = new RBush();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n    options.pixelTolerance : 10;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.snappedToVertex_ = false;\n\n  /**\n   * Indicate whether the interaction is currently changing a feature's\n   * coordinates.\n   * @type {boolean}\n   * @private\n   */\n  this.changingFeature_ = false;\n\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.dragSegments_ = [];\n\n  /**\n   * Draw overlay where sketch features are drawn.\n   * @type {ol.layer.Vector}\n   * @private\n   */\n  this.overlay_ = new VectorLayer({\n    source: new VectorSource({\n      useSpatialIndex: false,\n      wrapX: !!options.wrapX\n    }),\n    style: options.style ? options.style :\n      Modify.getDefaultStyleFunction(),\n    updateWhileAnimating: true,\n    updateWhileInteracting: true\n  });\n\n  /**\n  * @const\n  * @private\n  * @type {Object.<string, function(ol.Feature, ol.geom.Geometry)>}\n  */\n  this.SEGMENT_WRITERS_ = {\n    'Point': this.writePointGeometry_,\n    'LineString': this.writeLineStringGeometry_,\n    'LinearRing': this.writeLineStringGeometry_,\n    'Polygon': this.writePolygonGeometry_,\n    'MultiPoint': this.writeMultiPointGeometry_,\n    'MultiLineString': this.writeMultiLineStringGeometry_,\n    'MultiPolygon': this.writeMultiPolygonGeometry_,\n    'Circle': this.writeCircleGeometry_,\n    'GeometryCollection': this.writeGeometryCollectionGeometry_\n  };\n\n\n  /**\n   * @type {ol.source.Vector}\n   * @private\n   */\n  this.source_ = null;\n\n  let features;\n  if (options.source) {\n    this.source_ = options.source;\n    features = new Collection(this.source_.getFeatures());\n    listen(this.source_, VectorEventType.ADDFEATURE,\n      this.handleSourceAdd_, this);\n    listen(this.source_, VectorEventType.REMOVEFEATURE,\n      this.handleSourceRemove_, this);\n  } else {\n    features = options.features;\n  }\n  if (!features) {\n    throw new Error('The modify interaction requires features or a source');\n  }\n\n  /**\n   * @type {ol.Collection.<ol.Feature>}\n   * @private\n   */\n  this.features_ = features;\n\n  this.features_.forEach(this.addFeature_.bind(this));\n  listen(this.features_, CollectionEventType.ADD,\n    this.handleFeatureAdd_, this);\n  listen(this.features_, CollectionEventType.REMOVE,\n    this.handleFeatureRemove_, this);\n\n  /**\n   * @type {ol.MapBrowserPointerEvent}\n   * @private\n   */\n  this.lastPointerEvent_ = null;\n\n};\n\ninherits(Modify, PointerInteraction);\n\n\n/**\n * @define {number} The segment index assigned to a circle's center when\n * breaking up a cicrle into ModifySegmentDataType segments.\n */\nModify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX = 0;\n\n/**\n * @define {number} The segment index assigned to a circle's circumference when\n * breaking up a circle into ModifySegmentDataType segments.\n */\nModify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX = 1;\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.addFeature_ = function(feature) {\n  const geometry = feature.getGeometry();\n  if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {\n    this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);\n  }\n  const map = this.getMap();\n  if (map && map.isRendered() && this.getActive()) {\n    this.handlePointerAtPixel_(this.lastPixel_, map);\n  }\n  listen(feature, EventType.CHANGE,\n    this.handleFeatureChange_, this);\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Map browser event\n * @private\n */\nModify.prototype.willModifyFeatures_ = function(evt) {\n  if (!this.modified_) {\n    this.modified_ = true;\n    this.dispatchEvent(new Modify.Event(\n      ModifyEventType.MODIFYSTART, this.features_, evt));\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.removeFeature_ = function(feature) {\n  this.removeFeatureSegmentData_(feature);\n  // Remove the vertex feature if the collection of canditate features\n  // is empty.\n  if (this.vertexFeature_ && this.features_.getLength() === 0) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n  unlisten(feature, EventType.CHANGE,\n    this.handleFeatureChange_, this);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nModify.prototype.removeFeatureSegmentData_ = function(feature) {\n  const rBush = this.rBush_;\n  const /** @type {Array.<ol.ModifySegmentDataType>} */ nodesToRemove = [];\n  rBush.forEach(\n    /**\n     * @param {ol.ModifySegmentDataType} node RTree node.\n     */\n    function(node) {\n      if (feature === node.feature) {\n        nodesToRemove.push(node);\n      }\n    });\n  for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n    rBush.remove(nodesToRemove[i]);\n  }\n};\n\n\n/**\n * @inheritDoc\n */\nModify.prototype.setActive = function(active) {\n  if (this.vertexFeature_ && !active) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n  PointerInteraction.prototype.setActive.call(this, active);\n};\n\n\n/**\n * @inheritDoc\n */\nModify.prototype.setMap = function(map) {\n  this.overlay_.setMap(map);\n  PointerInteraction.prototype.setMap.call(this, map);\n};\n\n\n/**\n * @param {ol.source.Vector.Event} event Event.\n * @private\n */\nModify.prototype.handleSourceAdd_ = function(event) {\n  if (event.feature) {\n    this.features_.push(event.feature);\n  }\n};\n\n\n/**\n * @param {ol.source.Vector.Event} event Event.\n * @private\n */\nModify.prototype.handleSourceRemove_ = function(event) {\n  if (event.feature) {\n    this.features_.remove(event.feature);\n  }\n};\n\n\n/**\n * @param {ol.CollectionEvent} evt Event.\n * @private\n */\nModify.prototype.handleFeatureAdd_ = function(evt) {\n  this.addFeature_(/** @type {ol.Feature} */ (evt.element));\n};\n\n\n/**\n * @param {ol.events.Event} evt Event.\n * @private\n */\nModify.prototype.handleFeatureChange_ = function(evt) {\n  if (!this.changingFeature_) {\n    const feature = /** @type {ol.Feature} */ (evt.target);\n    this.removeFeature_(feature);\n    this.addFeature_(feature);\n  }\n};\n\n\n/**\n * @param {ol.CollectionEvent} evt Event.\n * @private\n */\nModify.prototype.handleFeatureRemove_ = function(evt) {\n  const feature = /** @type {ol.Feature} */ (evt.element);\n  this.removeFeature_(feature);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.Point} geometry Geometry.\n * @private\n */\nModify.prototype.writePointGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n  const segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    segment: [coordinates, coordinates]\n  });\n  this.rBush_.insert(geometry.getExtent(), segmentData);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiPoint} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiPointGeometry_ = function(feature, geometry) {\n  const points = geometry.getCoordinates();\n  let coordinates, i, ii, segmentData;\n  for (i = 0, ii = points.length; i < ii; ++i) {\n    coordinates = points[i];\n    segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      depth: [i],\n      index: i,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.LineString} geometry Geometry.\n * @private\n */\nModify.prototype.writeLineStringGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCoordinates();\n  let i, ii, segment, segmentData;\n  for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n    segment = coordinates.slice(i, i + 2);\n    segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n      feature: feature,\n      geometry: geometry,\n      index: i,\n      segment: segment\n    });\n    this.rBush_.insert(boundingExtent(segment), segmentData);\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiLineString} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {\n  const lines = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, segment, segmentData;\n  for (j = 0, jj = lines.length; j < jj; ++j) {\n    coordinates = lines[j];\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [j],\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.Polygon} geometry Geometry.\n * @private\n */\nModify.prototype.writePolygonGeometry_ = function(feature, geometry) {\n  const rings = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, segment, segmentData;\n  for (j = 0, jj = rings.length; j < jj; ++j) {\n    coordinates = rings[j];\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [j],\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.MultiPolygon} geometry Geometry.\n * @private\n */\nModify.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {\n  const polygons = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, k, kk, rings, segment, segmentData;\n  for (k = 0, kk = polygons.length; k < kk; ++k) {\n    rings = polygons[k];\n    for (j = 0, jj = rings.length; j < jj; ++j) {\n      coordinates = rings[j];\n      for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        segment = coordinates.slice(i, i + 2);\n        segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          feature: feature,\n          geometry: geometry,\n          depth: [j, k],\n          index: i,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n};\n\n\n/**\n * We convert a circle into two segments.  The segment at index\n * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX} is the\n * circle's center (a point).  The segment at index\n * {@link ol.interaction.Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX} is\n * the circumference, and is not a line segment.\n *\n * @param {ol.Feature} feature Feature.\n * @param {ol.geom.Circle} geometry Geometry.\n * @private\n */\nModify.prototype.writeCircleGeometry_ = function(feature, geometry) {\n  const coordinates = geometry.getCenter();\n  const centerSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    index: Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX,\n    segment: [coordinates, coordinates]\n  });\n  const circumferenceSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    feature: feature,\n    geometry: geometry,\n    index: Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX,\n    segment: [coordinates, coordinates]\n  });\n  const featureSegments = [centerSegmentData, circumferenceSegmentData];\n  centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;\n  this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n  this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.GeometryCollection} geometry Geometry.\n * @private\n */\nModify.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {\n  const geometries = geometry.getGeometriesArray();\n  for (let i = 0; i < geometries.length; ++i) {\n    this.SEGMENT_WRITERS_[geometries[i].getType()].call(this, feature, geometries[i]);\n  }\n};\n\n\n/**\n * @param {ol.Coordinate} coordinates Coordinates.\n * @return {ol.Feature} Vertex feature.\n * @private\n */\nModify.prototype.createOrUpdateVertexFeature_ = function(coordinates) {\n  let vertexFeature = this.vertexFeature_;\n  if (!vertexFeature) {\n    vertexFeature = new Feature(new Point(coordinates));\n    this.vertexFeature_ = vertexFeature;\n    this.overlay_.getSource().addFeature(vertexFeature);\n  } else {\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    geometry.setCoordinates(coordinates);\n  }\n  return vertexFeature;\n};\n\n\n/**\n * @param {ol.ModifySegmentDataType} a The first segment data.\n * @param {ol.ModifySegmentDataType} b The second segment data.\n * @return {number} The difference in indexes.\n */\nfunction compareIndexes(a, b) {\n  return a.index - b.index;\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Start drag sequence?\n * @this {ol.interaction.Modify}\n */\nfunction handleDownEvent(evt) {\n  if (!this.condition_(evt)) {\n    return false;\n  }\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n  const pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);\n  this.dragSegments_.length = 0;\n  this.modified_ = false;\n  const vertexFeature = this.vertexFeature_;\n  if (vertexFeature) {\n    const insertVertices = [];\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    const vertex = geometry.getCoordinates();\n    const vertexExtent = boundingExtent([vertex]);\n    const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n    const componentSegments = {};\n    segmentDataMatches.sort(compareIndexes);\n    for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n      const segmentDataMatch = segmentDataMatches[i];\n      const segment = segmentDataMatch.segment;\n      let uid = getUid(segmentDataMatch.feature);\n      const depth = segmentDataMatch.depth;\n      if (depth) {\n        uid += '-' + depth.join('-'); // separate feature components\n      }\n      if (!componentSegments[uid]) {\n        componentSegments[uid] = new Array(2);\n      }\n      if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE &&\n      segmentDataMatch.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n\n        const closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);\n        if (coordinatesEqual(closestVertex, vertex) && !componentSegments[uid][0]) {\n          this.dragSegments_.push([segmentDataMatch, 0]);\n          componentSegments[uid][0] = segmentDataMatch;\n        }\n      } else if (coordinatesEqual(segment[0], vertex) &&\n          !componentSegments[uid][0]) {\n        this.dragSegments_.push([segmentDataMatch, 0]);\n        componentSegments[uid][0] = segmentDataMatch;\n      } else if (coordinatesEqual(segment[1], vertex) &&\n          !componentSegments[uid][1]) {\n\n        // prevent dragging closed linestrings by the connecting node\n        if ((segmentDataMatch.geometry.getType() ===\n            GeometryType.LINE_STRING ||\n            segmentDataMatch.geometry.getType() ===\n            GeometryType.MULTI_LINE_STRING) &&\n            componentSegments[uid][0] &&\n            componentSegments[uid][0].index === 0) {\n          continue;\n        }\n\n        this.dragSegments_.push([segmentDataMatch, 1]);\n        componentSegments[uid][1] = segmentDataMatch;\n      } else if (this.insertVertexCondition_(evt) && getUid(segment) in this.vertexSegments_ &&\n          (!componentSegments[uid][0] && !componentSegments[uid][1])) {\n        insertVertices.push([segmentDataMatch, vertex]);\n      }\n    }\n    if (insertVertices.length) {\n      this.willModifyFeatures_(evt);\n    }\n    for (let j = insertVertices.length - 1; j >= 0; --j) {\n      this.insertVertex_.apply(this, insertVertices[j]);\n    }\n  }\n  return !!this.vertexFeature_;\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @this {ol.interaction.Modify}\n */\nfunction handleDragEvent(evt) {\n  this.ignoreNextSingleClick_ = false;\n  this.willModifyFeatures_(evt);\n\n  const vertex = evt.coordinate;\n  for (let i = 0, ii = this.dragSegments_.length; i < ii; ++i) {\n    const dragSegment = this.dragSegments_[i];\n    const segmentData = dragSegment[0];\n    const depth = segmentData.depth;\n    const geometry = segmentData.geometry;\n    let coordinates;\n    const segment = segmentData.segment;\n    const index = dragSegment[1];\n\n    while (vertex.length < geometry.getStride()) {\n      vertex.push(segment[index][vertex.length]);\n    }\n\n    switch (geometry.getType()) {\n      case GeometryType.POINT:\n        coordinates = vertex;\n        segment[0] = segment[1] = vertex;\n        break;\n      case GeometryType.MULTI_POINT:\n        coordinates = geometry.getCoordinates();\n        coordinates[segmentData.index] = vertex;\n        segment[0] = segment[1] = vertex;\n        break;\n      case GeometryType.LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates[segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.MULTI_LINE_STRING:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.MULTI_POLYGON:\n        coordinates = geometry.getCoordinates();\n        coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;\n        segment[index] = vertex;\n        break;\n      case GeometryType.CIRCLE:\n        segment[0] = segment[1] = vertex;\n        if (segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CENTER_INDEX) {\n          this.changingFeature_ = true;\n          geometry.setCenter(vertex);\n          this.changingFeature_ = false;\n        } else { // We're dragging the circle's circumference:\n          this.changingFeature_ = true;\n          geometry.setRadius(coordinateDistance(geometry.getCenter(), vertex));\n          this.changingFeature_ = false;\n        }\n        break;\n      default:\n        // pass\n    }\n\n    if (coordinates) {\n      this.setGeometryCoordinates_(geometry, coordinates);\n    }\n  }\n  this.createOrUpdateVertexFeature_(vertex);\n}\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {ol.interaction.Modify}\n */\nfunction handleUpEvent(evt) {\n  let segmentData;\n  let geometry;\n  for (let i = this.dragSegments_.length - 1; i >= 0; --i) {\n    segmentData = this.dragSegments_[i][0];\n    geometry = segmentData.geometry;\n    if (geometry.getType() === GeometryType.CIRCLE) {\n      // Update a circle object in the R* bush:\n      const coordinates = geometry.getCenter();\n      const centerSegmentData = segmentData.featureSegments[0];\n      const circumferenceSegmentData = segmentData.featureSegments[1];\n      centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;\n      circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;\n      this.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);\n      this.rBush_.update(geometry.getExtent(), circumferenceSegmentData);\n    } else {\n      this.rBush_.update(boundingExtent(segmentData.segment),\n        segmentData);\n    }\n  }\n  if (this.modified_) {\n    this.dispatchEvent(new Modify.Event(\n      ModifyEventType.MODIFYEND, this.features_, evt));\n    this.modified_ = false;\n  }\n  return false;\n}\n\n\n/**\n * Handles the {@link ol.MapBrowserEvent map browser event} and may modify the\n * geometry.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {ol.interaction.Modify}\n */\nfunction handleEvent(mapBrowserEvent) {\n  if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {\n    return true;\n  }\n  this.lastPointerEvent_ = mapBrowserEvent;\n\n  let handled;\n  if (!mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&\n      !this.handlingDownUpSequence) {\n    this.handlePointerMove_(mapBrowserEvent);\n  }\n  if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {\n    if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {\n      handled = this.removePoint();\n    } else {\n      handled = true;\n    }\n  }\n\n  if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {\n    this.ignoreNextSingleClick_ = false;\n  }\n\n  return handlePointerEvent.call(this, mapBrowserEvent) && !handled;\n}\n\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @private\n */\nModify.prototype.handlePointerMove_ = function(evt) {\n  this.lastPixel_ = evt.pixel;\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n};\n\n\n/**\n * @param {ol.Pixel} pixel Pixel\n * @param {ol.PluggableMap} map Map.\n * @private\n */\nModify.prototype.handlePointerAtPixel_ = function(pixel, map) {\n  const pixelCoordinate = map.getCoordinateFromPixel(pixel);\n  const sortByDistance = function(a, b) {\n    return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -\n        pointDistanceToSegmentDataSquared(pixelCoordinate, b);\n  };\n\n  const box = buffer(createOrUpdateFromCoordinate(pixelCoordinate),\n    map.getView().getResolution() * this.pixelTolerance_);\n\n  const rBush = this.rBush_;\n  const nodes = rBush.getInExtent(box);\n  if (nodes.length > 0) {\n    nodes.sort(sortByDistance);\n    const node = nodes[0];\n    const closestSegment = node.segment;\n    let vertex = closestOnSegmentData(pixelCoordinate, node);\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\n    let dist = coordinateDistance(pixel, vertexPixel);\n    if (dist <= this.pixelTolerance_) {\n      const vertexSegments = {};\n\n      if (node.geometry.getType() === GeometryType.CIRCLE &&\n      node.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n\n        this.snappedToVertex_ = true;\n        this.createOrUpdateVertexFeature_(vertex);\n      } else {\n        const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        const squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n        const squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        this.snappedToVertex_ = dist <= this.pixelTolerance_;\n        if (this.snappedToVertex_) {\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n        }\n        this.createOrUpdateVertexFeature_(vertex);\n        let segment;\n        for (let i = 1, ii = nodes.length; i < ii; ++i) {\n          segment = nodes[i].segment;\n          if ((coordinatesEqual(closestSegment[0], segment[0]) &&\n              coordinatesEqual(closestSegment[1], segment[1]) ||\n              (coordinatesEqual(closestSegment[0], segment[1]) &&\n              coordinatesEqual(closestSegment[1], segment[0])))) {\n            vertexSegments[getUid(segment)] = true;\n          } else {\n            break;\n          }\n        }\n      }\n\n      vertexSegments[getUid(closestSegment)] = true;\n      this.vertexSegments_ = vertexSegments;\n      return;\n    }\n  }\n  if (this.vertexFeature_) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n};\n\n\n/**\n * Returns the distance from a point to a line segment.\n *\n * @param {ol.Coordinate} pointCoordinates The coordinates of the point from\n *        which to calculate the distance.\n * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n *        segment we are calculating the distance to.\n * @return {number} The square of the distance between a point and a line segment.\n */\nfunction pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === GeometryType.CIRCLE) {\n    const circleGeometry = /** @type {ol.geom.Circle} */ (geometry);\n\n    if (segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n      const distanceToCenterSquared =\n            squaredCoordinateDistance(circleGeometry.getCenter(), pointCoordinates);\n      const distanceToCircumference =\n            Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();\n      return distanceToCircumference * distanceToCircumference;\n    }\n  }\n  return squaredDistanceToSegment(pointCoordinates, segmentData.segment);\n}\n\n/**\n * Returns the point closest to a given line segment.\n *\n * @param {ol.Coordinate} pointCoordinates The point to which a closest point\n *        should be found.\n * @param {ol.ModifySegmentDataType} segmentData The object describing the line\n *        segment which should contain the closest point.\n * @return {ol.Coordinate} The point closest to the specified line segment.\n */\nfunction closestOnSegmentData(pointCoordinates, segmentData) {\n  const geometry = segmentData.geometry;\n\n  if (geometry.getType() === GeometryType.CIRCLE &&\n  segmentData.index === Modify.MODIFY_SEGMENT_CIRCLE_CIRCUMFERENCE_INDEX) {\n    return geometry.getClosestPoint(pointCoordinates);\n  }\n  return closestOnSegment(pointCoordinates, segmentData.segment);\n}\n\n\n/**\n * @param {ol.ModifySegmentDataType} segmentData Segment data.\n * @param {ol.Coordinate} vertex Vertex.\n * @private\n */\nModify.prototype.insertVertex_ = function(segmentData, vertex) {\n  const segment = segmentData.segment;\n  const feature = segmentData.feature;\n  const geometry = segmentData.geometry;\n  const depth = segmentData.depth;\n  const index = /** @type {number} */ (segmentData.index);\n  let coordinates;\n\n  while (vertex.length < geometry.getStride()) {\n    vertex.push(0);\n  }\n\n  switch (geometry.getType()) {\n    case GeometryType.MULTI_LINE_STRING:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.POLYGON:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.MULTI_POLYGON:\n      coordinates = geometry.getCoordinates();\n      coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);\n      break;\n    case GeometryType.LINE_STRING:\n      coordinates = geometry.getCoordinates();\n      coordinates.splice(index + 1, 0, vertex);\n      break;\n    default:\n      return;\n  }\n\n  this.setGeometryCoordinates_(geometry, coordinates);\n  const rTree = this.rBush_;\n  rTree.remove(segmentData);\n  this.updateSegmentIndices_(geometry, index, depth, 1);\n  const newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n    segment: [segment[0], vertex],\n    feature: feature,\n    geometry: geometry,\n    depth: depth,\n    index: index\n  });\n  rTree.insert(boundingExtent(newSegmentData.segment),\n    newSegmentData);\n  this.dragSegments_.push([newSegmentData, 1]);\n\n  const newSegmentData2 = /** @type {ol.ModifySegmentDataType} */ ({\n    segment: [vertex, segment[1]],\n    feature: feature,\n    geometry: geometry,\n    depth: depth,\n    index: index + 1\n  });\n  rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);\n  this.dragSegments_.push([newSegmentData2, 0]);\n  this.ignoreNextSingleClick_ = true;\n};\n\n/**\n * Removes the vertex currently being pointed.\n * @return {boolean} True when a vertex was removed.\n * @api\n */\nModify.prototype.removePoint = function() {\n  if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {\n    const evt = this.lastPointerEvent_;\n    this.willModifyFeatures_(evt);\n    this.removeVertex_();\n    this.dispatchEvent(new Modify.Event(ModifyEventType.MODIFYEND, this.features_, evt));\n    this.modified_ = false;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes a vertex from all matching features.\n * @return {boolean} True when a vertex was removed.\n * @private\n */\nModify.prototype.removeVertex_ = function() {\n  const dragSegments = this.dragSegments_;\n  const segmentsByFeature = {};\n  let deleted = false;\n  let component, coordinates, dragSegment, geometry, i, index, left;\n  let newIndex, right, segmentData, uid;\n  for (i = dragSegments.length - 1; i >= 0; --i) {\n    dragSegment = dragSegments[i];\n    segmentData = dragSegment[0];\n    uid = getUid(segmentData.feature);\n    if (segmentData.depth) {\n      // separate feature components\n      uid += '-' + segmentData.depth.join('-');\n    }\n    if (!(uid in segmentsByFeature)) {\n      segmentsByFeature[uid] = {};\n    }\n    if (dragSegment[1] === 0) {\n      segmentsByFeature[uid].right = segmentData;\n      segmentsByFeature[uid].index = segmentData.index;\n    } else if (dragSegment[1] == 1) {\n      segmentsByFeature[uid].left = segmentData;\n      segmentsByFeature[uid].index = segmentData.index + 1;\n    }\n\n  }\n  for (uid in segmentsByFeature) {\n    right = segmentsByFeature[uid].right;\n    left = segmentsByFeature[uid].left;\n    index = segmentsByFeature[uid].index;\n    newIndex = index - 1;\n    if (left !== undefined) {\n      segmentData = left;\n    } else {\n      segmentData = right;\n    }\n    if (newIndex < 0) {\n      newIndex = 0;\n    }\n    geometry = segmentData.geometry;\n    coordinates = geometry.getCoordinates();\n    component = coordinates;\n    deleted = false;\n    switch (geometry.getType()) {\n      case GeometryType.MULTI_LINE_STRING:\n        if (coordinates[segmentData.depth[0]].length > 2) {\n          coordinates[segmentData.depth[0]].splice(index, 1);\n          deleted = true;\n        }\n        break;\n      case GeometryType.LINE_STRING:\n        if (coordinates.length > 2) {\n          coordinates.splice(index, 1);\n          deleted = true;\n        }\n        break;\n      case GeometryType.MULTI_POLYGON:\n        component = component[segmentData.depth[1]];\n        /* falls through */\n      case GeometryType.POLYGON:\n        component = component[segmentData.depth[0]];\n        if (component.length > 4) {\n          if (index == component.length - 1) {\n            index = 0;\n          }\n          component.splice(index, 1);\n          deleted = true;\n          if (index === 0) {\n            // close the ring again\n            component.pop();\n            component.push(component[0]);\n            newIndex = component.length - 1;\n          }\n        }\n        break;\n      default:\n        // pass\n    }\n\n    if (deleted) {\n      this.setGeometryCoordinates_(geometry, coordinates);\n      const segments = [];\n      if (left !== undefined) {\n        this.rBush_.remove(left);\n        segments.push(left.segment[0]);\n      }\n      if (right !== undefined) {\n        this.rBush_.remove(right);\n        segments.push(right.segment[1]);\n      }\n      if (left !== undefined && right !== undefined) {\n        const newSegmentData = /** @type {ol.ModifySegmentDataType} */ ({\n          depth: segmentData.depth,\n          feature: segmentData.feature,\n          geometry: segmentData.geometry,\n          index: newIndex,\n          segment: segments\n        });\n        this.rBush_.insert(boundingExtent(newSegmentData.segment),\n          newSegmentData);\n      }\n      this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);\n      if (this.vertexFeature_) {\n        this.overlay_.getSource().removeFeature(this.vertexFeature_);\n        this.vertexFeature_ = null;\n      }\n      dragSegments.length = 0;\n    }\n\n  }\n  return deleted;\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} geometry Geometry.\n * @param {Array} coordinates Coordinates.\n * @private\n */\nModify.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {\n  this.changingFeature_ = true;\n  geometry.setCoordinates(coordinates);\n  this.changingFeature_ = false;\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} geometry Geometry.\n * @param {number} index Index.\n * @param {Array.<number>|undefined} depth Depth.\n * @param {number} delta Delta (1 or -1).\n * @private\n */\nModify.prototype.updateSegmentIndices_ = function(\n  geometry, index, depth, delta) {\n  this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {\n    if (segmentDataMatch.geometry === geometry &&\n        (depth === undefined || segmentDataMatch.depth === undefined ||\n        equals(segmentDataMatch.depth, depth)) &&\n        segmentDataMatch.index > index) {\n      segmentDataMatch.index += delta;\n    }\n  });\n};\n\n\n/**\n * @return {ol.StyleFunction} Styles.\n */\nModify.getDefaultStyleFunction = function() {\n  const style = Style.createDefaultEditing();\n  return function(feature, resolution) {\n    return style[GeometryType.POINT];\n  };\n};\n\n\n/**\n * @classdesc\n * Events emitted by {@link ol.interaction.Modify} instances are instances of\n * this type.\n *\n * @constructor\n * @extends {ol.events.Event}\n * @implements {oli.ModifyEvent}\n * @param {ol.interaction.ModifyEventType} type Type.\n * @param {ol.Collection.<ol.Feature>} features The features modified.\n * @param {ol.MapBrowserPointerEvent} mapBrowserPointerEvent Associated\n *     {@link ol.MapBrowserPointerEvent}.\n */\nModify.Event = function(type, features, mapBrowserPointerEvent) {\n\n  Event.call(this, type);\n\n  /**\n   * The features being modified.\n   * @type {ol.Collection.<ol.Feature>}\n   * @api\n   */\n  this.features = features;\n\n  /**\n   * Associated {@link ol.MapBrowserEvent}.\n   * @type {ol.MapBrowserEvent}\n   * @api\n   */\n  this.mapBrowserEvent = mapBrowserPointerEvent;\n};\n\ninherits(Modify.Event, Event);\n\nexport default Modify;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/interaction/Modify.js\n// module id = null\n// module chunks = ","/**\n * @module ol/source/OSM\n */\nimport {inherits} from '../index.js';\nimport XYZ from '../source/XYZ.js';\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n *\n * @constructor\n * @extends {ol.source.XYZ}\n * @param {olx.source.OSMOptions=} opt_options Open Street Map options.\n * @api\n */\nconst OSM = function(opt_options) {\n\n  const options = opt_options || {};\n\n  let attributions;\n  if (options.attributions !== undefined) {\n    attributions = options.attributions;\n  } else {\n    attributions = [OSM.ATTRIBUTION];\n  }\n\n  const crossOrigin = options.crossOrigin !== undefined ?\n    options.crossOrigin : 'anonymous';\n\n  const url = options.url !== undefined ?\n    options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n  XYZ.call(this, {\n    attributions: attributions,\n    cacheSize: options.cacheSize,\n    crossOrigin: crossOrigin,\n    opaque: options.opaque !== undefined ? options.opaque : true,\n    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n    tileLoadFunction: options.tileLoadFunction,\n    url: url,\n    wrapX: options.wrapX\n  });\n\n};\n\ninherits(OSM, XYZ);\n\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\nOSM.ATTRIBUTION = '&copy; ' +\n      '<a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> ' +\n      'contributors.';\nexport default OSM;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/source/OSM.js\n// module id = 4\n// module chunks = 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26","/**\n * @module app.modifycircle\n */\nconst exports = {};\n\nimport './modifycircle.css';\nimport './common_dependencies.js';\nimport ngeoFormatFeatureProperties from 'ngeo/format/FeatureProperties.js';\n\nimport ngeoInteractionModifyCircle from 'ngeo/interaction/ModifyCircle.js';\nimport olMap from 'ol/Map.js';\nimport olView from 'ol/View.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olSourceOSM from 'ol/source/OSM.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olGeomCircle from 'ol/geom/Circle.js';\nimport olGeomPolygon from 'ol/geom/Polygon.js';\nimport olCollection from 'ol/Collection.js';\nimport olFeature from 'ol/Feature.js';\nimport ngeoMapModule from 'ngeo/map/module.js';\n\n\n/** @type {!angular.Module} **/\nconst module = angular.module('app', [\n  ngeoMapModule.name\n]);\n\n\n/**\n * @constructor\n * @ngInject\n */\nexports.MainController = function() {\n\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map = new olMap({\n    layers: [\n      new olLayerTile({\n        source: new olSourceOSM()\n      })\n    ],\n    view: new olView({\n      center: [-10997148, 4569099],\n      zoom: 4\n    })\n  });\n\n  const map = this.map;\n\n  const circle = new olGeomCircle([-10691093, 4966327], 465000);\n\n  /**\n   * @type {ol.Collection.<ol.Feature>}\n   * @export\n   */\n  this.features = new olCollection();\n\n  const circleFeature = new olFeature({\n    geometry: olGeomPolygon.fromCircle(circle),\n    color: '#000000',\n    label: 'Circle 1',\n    opacity: '0.5',\n    stroke: '2'\n  });\n\n  circleFeature.set(ngeoFormatFeatureProperties.IS_CIRCLE, true);\n  this.features.push(circleFeature);\n\n  const vectorSource = new olSourceVector({\n    features: this.features\n  });\n  const vectorLayer = new olLayerVector({\n    source: vectorSource\n  });\n\n  // Use vectorLayer.setMap(map) rather than map.addLayer(vectorLayer). This\n  // makes the vector layer \"unmanaged\", meaning that it is always on top.\n  vectorLayer.setMap(map);\n\n  /**\n   * @type {ngeo.interaction.ModifyCircle}\n   * @export\n   */\n  this.interaction = new ngeoInteractionModifyCircle(\n    /** @type {olx.interaction.ModifyOptions} */({\n      features: this.features\n    }));\n\n  const interaction = this.interaction;\n  interaction.setActive(true);\n  map.addInteraction(interaction);\n\n};\n\n\nmodule.controller('MainController', exports.MainController);\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./examples/modifycircle.js","/**\n * @module ngeo.interaction.ModifyCircle\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoFormatFeatureProperties from 'ngeo/format/FeatureProperties.js';\nimport ngeoInteractionMeasureAzimut from 'ngeo/interaction/MeasureAzimut.js';\nimport * as olBase from 'ol/index.js';\nimport olFeature from 'ol/Feature.js';\nimport olMapBrowserPointerEvent from 'ol/MapBrowserPointerEvent.js';\nimport * as olCoordinate from 'ol/coordinate.js';\nimport * as olEvents from 'ol/events.js';\nimport * as olExtent from 'ol/extent.js';\nimport olGeomCircle from 'ol/geom/Circle.js';\nimport olGeomLineString from 'ol/geom/LineString.js';\nimport olGeomPoint from 'ol/geom/Point.js';\nimport olGeomPolygon from 'ol/geom/Polygon.js';\nimport olInteractionModify from 'ol/interaction/Modify.js';\nimport olInteractionPointer from 'ol/interaction/Pointer.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olStructsRBush from 'ol/structs/RBush.js';\nimport olStyleStyle from 'ol/style/Style.js';\n\n/**\n * @classdesc\n * Interaction for modifying feature geometries.\n *\n * @constructor\n * @struct\n * @extends {ol.interaction.Pointer}\n * @param {olx.interaction.ModifyOptions} options Options.\n * @fires ngeo.interaction.ModifyCircleEvent\n * @api\n */\nconst exports = function(options) {\n\n  googAsserts.assert(options.features);\n\n  olInteractionPointer.call(this, {\n    handleDownEvent: exports.handleDownEvent_,\n    handleDragEvent: exports.handleDragEvent_,\n    handleEvent: exports.handleEvent,\n    handleUpEvent: exports.handleUpEvent_\n  });\n\n  /**\n   * Editing vertex.\n   * @type {ol.Feature}\n   * @private\n   */\n  this.vertexFeature_ = null;\n\n  /**\n   * @type {ol.Pixel}\n   * @private\n   */\n  this.lastPixel_ = [0, 0];\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.modified_ = false;\n\n  /**\n   * Segment RTree for each layer\n   * @type {ol.structs.RBush.<ol.ModifySegmentDataType>}\n   * @private\n   */\n  this.rBush_ = new olStructsRBush();\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n    options.pixelTolerance : 10;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.snappedToVertex_ = false;\n\n  /**\n   * Indicate whether the interaction is currently changing a feature's\n   * coordinates.\n   * @type {boolean}\n   * @private\n   */\n  this.changingFeature_ = false;\n\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.dragSegments_ = null;\n\n  /**\n   * Draw overlay where sketch features are drawn.\n   * @type {ol.layer.Vector}\n   * @private\n   */\n  this.overlay_ = new olLayerVector({\n    source: new olSourceVector({\n      useSpatialIndex: false,\n      wrapX: !!options.wrapX\n    }),\n    style: options.style ? options.style :\n      exports.getDefaultStyleFunction(),\n    updateWhileAnimating: true,\n    updateWhileInteracting: true\n  });\n\n  /**\n   * @type {!ol.Collection.<ol.Feature>}\n   * @private\n   */\n  this.features_ = options.features;\n\n  this.features_.forEach(this.addFeature_, this);\n  olEvents.listen(this.features_, 'add', this.handleFeatureAdd_, this);\n  olEvents.listen(this.features_, 'remove', this.handleFeatureRemove_, this);\n\n};\n\nolBase.inherits(exports, olInteractionPointer);\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.prototype.addFeature_ = function(feature) {\n  if (feature.getGeometry().getType() === 'Polygon' &&\n      !!feature.get(ngeoFormatFeatureProperties.IS_CIRCLE)) {\n    const geometry = /** @type {ol.geom.Polygon}*/ (feature.getGeometry());\n    this.writeCircleGeometry_(feature, geometry);\n\n    const map = this.getMap();\n    if (map) {\n      this.handlePointerAtPixel_(this.lastPixel_, map);\n    }\n  }\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Map browser event\n * @private\n */\nexports.prototype.willModifyFeatures_ = function(evt) {\n  if (!this.modified_) {\n    this.modified_ = true;\n    this.dispatchEvent(new olInteractionModify.Event(\n      /** @type {ol.interaction.ModifyEventType} */ ('modifystart'), this.features_, evt));\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.prototype.removeFeature_ = function(feature) {\n  this.removeFeatureSegmentData_(feature);\n  // Remove the vertex feature if the collection of canditate features\n  // is empty.\n  if (this.vertexFeature_ && this.features_.getLength() === 0) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n};\n\n\n/**\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.prototype.removeFeatureSegmentData_ = function(feature) {\n  const rBush = this.rBush_;\n  const /** @type {Array.<ol.ModifySegmentDataType>} */ nodesToRemove = [];\n  rBush.forEach(\n    /**\n       * @param {ol.ModifySegmentDataType} node RTree node.\n       */\n    (node) => {\n      if (feature === node.feature) {\n        nodesToRemove.push(node);\n      }\n    });\n  for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n    rBush.remove(nodesToRemove[i]);\n  }\n};\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.setMap = function(map) {\n  this.overlay_.setMap(map);\n  olInteractionPointer.prototype.setMap.call(this, map);\n};\n\n\n/**\n * @param {ol.Collection.Event} evt Event.\n * @private\n */\nexports.prototype.handleFeatureAdd_ = function(evt) {\n  const feature = evt.element;\n  googAsserts.assertInstanceof(feature, olFeature,\n    'feature should be an ol.Feature');\n  this.addFeature_(feature);\n};\n\n\n/**\n * @param {ol.Collection.Event} evt Event.\n * @private\n */\nexports.prototype.handleFeatureRemove_ = function(evt) {\n  const feature = /** @type {ol.Feature} */ (evt.element);\n  this.removeFeature_(feature);\n};\n\n\n/**\n * @param {ol.Feature} feature Feature\n * @param {ol.geom.Polygon} geometry Geometry.\n * @private\n */\nexports.prototype.writeCircleGeometry_ = function(feature, geometry) {\n  const rings = geometry.getCoordinates();\n  let coordinates, i, ii, j, jj, segment, segmentData;\n  for (j = 0, jj = rings.length; j < jj; ++j) {\n    coordinates = rings[j];\n    for (i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      segment = coordinates.slice(i, i + 2);\n      segmentData = /** @type {ol.ModifySegmentDataType} */ ({\n        feature: feature,\n        geometry: geometry,\n        depth: [j],\n        index: i,\n        segment: segment\n      });\n      this.rBush_.insert(olExtent.boundingExtent(segment), segmentData);\n    }\n  }\n};\n\n\n/**\n * @param {ol.Coordinate} coordinates Coordinates.\n * @return {ol.Feature} Vertex feature.\n * @private\n */\nexports.prototype.createOrUpdateVertexFeature_ = function(coordinates) {\n  let vertexFeature = this.vertexFeature_;\n  if (!vertexFeature) {\n    vertexFeature = new olFeature(new olGeomPoint(coordinates));\n    this.vertexFeature_ = vertexFeature;\n    this.overlay_.getSource().addFeature(vertexFeature);\n  } else {\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    geometry.setCoordinates(coordinates);\n  }\n  return vertexFeature;\n};\n\n\n/**\n * @param {ol.ModifySegmentDataType} a The first segment data.\n * @param {ol.ModifySegmentDataType} b The second segment data.\n * @return {number} The difference in indexes.\n * @private\n */\nexports.compareIndexes_ = function(a, b) {\n  return a.index - b.index;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Start drag sequence?\n * @this {ngeo.interaction.ModifyCircle}\n * @private\n */\nexports.handleDownEvent_ = function(evt) {\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n  this.dragSegments_ = [];\n  this.modified_ = false;\n  const vertexFeature = this.vertexFeature_;\n  if (vertexFeature) {\n    const geometry = /** @type {ol.geom.Point} */ (vertexFeature.getGeometry());\n    const vertex = geometry.getCoordinates();\n    const vertexExtent = olExtent.boundingExtent([vertex]);\n    const segmentDataMatches = this.rBush_.getInExtent(vertexExtent);\n    const componentSegments = {};\n    segmentDataMatches.sort(exports.compareIndexes_);\n    for (let i = 0, ii = segmentDataMatches.length; i < ii; ++i) {\n      const segmentDataMatch = segmentDataMatches[i];\n      const segment = segmentDataMatch.segment;\n      let uid = olBase.getUid(segmentDataMatch.feature);\n      const depth = segmentDataMatch.depth;\n      if (depth) {\n        uid += `-${depth.join('-')}`; // separate feature components\n      }\n      if (!componentSegments[uid]) {\n        componentSegments[uid] = new Array(2);\n      }\n      if (olCoordinate.equals(segment[0], vertex) &&\n          !componentSegments[uid][0]) {\n        this.dragSegments_.push([segmentDataMatch, 0]);\n        componentSegments[uid][0] = segmentDataMatch;\n      } else if (olCoordinate.equals(segment[1], vertex) &&\n          !componentSegments[uid][1]) {\n        this.dragSegments_.push([segmentDataMatch, 1]);\n        componentSegments[uid][1] = segmentDataMatch;\n      }\n    }\n  }\n  return !!this.vertexFeature_;\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @this {ngeo.interaction.ModifyCircle}\n * @private\n */\nexports.handleDragEvent_ = function(evt) {\n  this.willModifyFeatures_(evt);\n  const vertex = evt.coordinate;\n  const geometry =\n      /** @type {ol.geom.Polygon}*/ (this.dragSegments_[0][0].geometry);\n  const center = olExtent.getCenter(geometry.getExtent());\n\n  const line = new olGeomLineString([center, vertex]);\n\n\n  /**\n   * @type {ol.geom.Circle}\n   */\n  const circle = new olGeomCircle(center, line.getLength());\n  const coordinates = olGeomPolygon.fromCircle(circle, 64).getCoordinates();\n  this.setGeometryCoordinates_(geometry, coordinates);\n\n\n  const azimut = ngeoInteractionMeasureAzimut.getAzimut(line);\n  this.features_.getArray()[0].set(ngeoFormatFeatureProperties.AZIMUT, azimut);\n\n  this.createOrUpdateVertexFeature_(vertex);\n};\n\n\n/**\n * @param {ol.MapBrowserPointerEvent} evt Event.\n * @return {boolean} Stop drag sequence?\n * @this {ngeo.interaction.ModifyCircle}\n * @private\n */\nexports.handleUpEvent_ = function(evt) {\n  this.rBush_.clear();\n  this.writeCircleGeometry_(this.dragSegments_[0][0].feature,\n    this.dragSegments_[0][0].geometry);\n\n  if (this.modified_) {\n    this.dispatchEvent(new olInteractionModify.Event(\n      /** @type {ol.interaction.ModifyEventType} */ ('modifyend'), this.features_, evt));\n    this.modified_ = false;\n  }\n  return false;\n};\n\n\n/**\n * Handles the {@link ol.MapBrowserEvent map browser event} and may modify the\n * geometry.\n * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {ngeo.interaction.ModifyCircle}\n * @api\n */\nexports.handleEvent = function(mapBrowserEvent) {\n  if (!(mapBrowserEvent instanceof olMapBrowserPointerEvent)) {\n    return true;\n  }\n\n  let handled;\n  if (!mapBrowserEvent.map.getView().getInteracting() &&\n      mapBrowserEvent.type == 'pointermove' && !this.handlingDownUpSequence) {\n    this.handlePointerMove_(mapBrowserEvent);\n  }\n\n  return olInteractionPointer.handleEvent.call(this, mapBrowserEvent) &&\n      !handled;\n};\n\n\n/**\n * @param {ol.MapBrowserEvent} evt Event.\n * @private\n */\nexports.prototype.handlePointerMove_ = function(evt) {\n  this.lastPixel_ = evt.pixel;\n  this.handlePointerAtPixel_(evt.pixel, evt.map);\n};\n\n\n/**\n * @param {ol.Pixel} pixel Pixel\n * @param {ol.PluggableMap} map Map.\n * @private\n */\nexports.prototype.handlePointerAtPixel_ = function(pixel, map) {\n  const pixelCoordinate = map.getCoordinateFromPixel(pixel);\n  const sortByDistance = function(a, b) {\n    return olCoordinate.squaredDistanceToSegment(pixelCoordinate, a.segment) -\n        olCoordinate.squaredDistanceToSegment(pixelCoordinate, b.segment);\n  };\n\n  const lowerLeft = map.getCoordinateFromPixel(\n    [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n  const upperRight = map.getCoordinateFromPixel(\n    [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n  const box = olExtent.boundingExtent([lowerLeft, upperRight]);\n\n  const rBush = this.rBush_;\n  const nodes = rBush.getInExtent(box);\n  if (nodes.length > 0) {\n    nodes.sort(sortByDistance);\n    const node = nodes[0];\n    const closestSegment = node.segment;\n    let vertex = (olCoordinate.closestOnSegment(pixelCoordinate,\n      closestSegment));\n    const vertexPixel = map.getPixelFromCoordinate(vertex);\n    if (Math.sqrt(olCoordinate.squaredDistance(pixel, vertexPixel)) <=\n        this.pixelTolerance_) {\n      const pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n      const pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n      const squaredDist1 = olCoordinate.squaredDistance(vertexPixel, pixel1);\n      const squaredDist2 = olCoordinate.squaredDistance(vertexPixel, pixel2);\n      const dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n      this.snappedToVertex_ = dist <= this.pixelTolerance_;\n      if (this.snappedToVertex_) {\n        vertex = squaredDist1 > squaredDist2 ?\n          closestSegment[1] : closestSegment[0];\n        this.createOrUpdateVertexFeature_(vertex);\n        const vertexSegments = {};\n        vertexSegments[olBase.getUid(closestSegment)] = true;\n        let segment;\n        for (let i = 1, ii = nodes.length; i < ii; ++i) {\n          segment = nodes[i].segment;\n          if ((olCoordinate.equals(closestSegment[0], segment[0]) &&\n              olCoordinate.equals(closestSegment[1], segment[1]) ||\n              (olCoordinate.equals(closestSegment[0], segment[1]) &&\n              olCoordinate.equals(closestSegment[1], segment[0])))) {\n            vertexSegments[olBase.getUid(segment)] = true;\n          } else {\n            break;\n          }\n        }\n        return;\n      }\n    }\n  }\n  if (this.vertexFeature_) {\n    this.overlay_.getSource().removeFeature(this.vertexFeature_);\n    this.vertexFeature_ = null;\n  }\n};\n\n\n/**\n * @param {ol.geom.SimpleGeometry} geometry Geometry.\n * @param {Array} coordinates Coordinates.\n * @private\n */\nexports.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {\n  this.changingFeature_ = true;\n  geometry.setCoordinates(coordinates);\n  this.changingFeature_ = false;\n};\n\n\n/**\n * @return {ol.StyleFunction} Styles.\n */\nexports.getDefaultStyleFunction = function() {\n  const style = olStyleStyle.createDefaultEditing();\n  return function(feature, resolution) {\n    return style[/**@type {ol.geom.GeometryType} */ ('Point')];\n  };\n};\n\n\nexport default exports;\n\n\n\n// WEBPACK FOOTER //\n// ./src/interaction/ModifyCircle.js","/**\n * @module ol/source/XYZ\n */\nimport {inherits} from '../index.js';\nimport TileImage from '../source/TileImage.js';\nimport {createXYZ, extentFromProjection} from '../tilegrid.js';\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case,\n * {@link ol.source.TileImage} can be used with a `tileUrlFunction`\n * such as:\n *\n *  tileUrlFunction: function(coordinate) {\n *    return 'http://mapserver.com/' + coordinate[0] + '/' +\n *        coordinate[1] + '/' + coordinate[2] + '.png';\n *    }\n *\n *\n * @constructor\n * @extends {ol.source.TileImage}\n * @param {olx.source.XYZOptions=} opt_options XYZ options.\n * @api\n */\nconst XYZ = function(opt_options) {\n  const options = opt_options || {};\n  const projection = options.projection !== undefined ?\n    options.projection : 'EPSG:3857';\n\n  const tileGrid = options.tileGrid !== undefined ? options.tileGrid :\n    createXYZ({\n      extent: extentFromProjection(projection),\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize\n    });\n\n  TileImage.call(this, {\n    attributions: options.attributions,\n    cacheSize: options.cacheSize,\n    crossOrigin: options.crossOrigin,\n    opaque: options.opaque,\n    projection: projection,\n    reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n    tileGrid: tileGrid,\n    tileLoadFunction: options.tileLoadFunction,\n    tilePixelRatio: options.tilePixelRatio,\n    tileUrlFunction: options.tileUrlFunction,\n    url: options.url,\n    urls: options.urls,\n    wrapX: options.wrapX !== undefined ? options.wrapX : true,\n    transition: options.transition\n  });\n\n};\n\ninherits(XYZ, TileImage);\nexport default XYZ;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/openlayers/src/ol/source/XYZ.js\n// module id = 5\n// module chunks = 1 2 3 4 5 6 7 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26"],"sourceRoot":""}